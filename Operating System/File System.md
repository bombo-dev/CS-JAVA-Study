# File System

파일 시스템은 파일을 질서있게 관리하기 위해 파일 시스템을 사용합니다. 파일은 **보조 저장 장치(ex. 디스크)에 정보를 저장하는 단위**이며, 메타데이터와 파일 내용을 따로 저장해두고, 메타 데이터는 i-node 에 의해 관리됩니다.

### Q) 유닉스 파일시스템의 i-node 에 관해 간략하게 설명해주세요.
i-node블록은 **메타데이터를 저장하기 위한 자료구조**로, 고유한 정수번호로 생성됩니다.
하나의 파일에 하나의 inode 생성되어 **각 파일의 위치 정보**를 가리킵니다. 따라서 내가 원하는 파일이 정확히 어떤 위치에 저장되어 있는 지 알 수 있습니다.

- **i-node (메타 데이터) 리스트**
  - **모드** : 파일의 타입과 허가 마스크
  - 링크 카운트 : i-node 번호와 함께 entry를 가지고 있는 디렉토리 수
  - **사용자 ID** : 파일의 소유자 ID
  - **그룹 ID** : 파일의 소유 그룹 ID
  - **크기** : 파일의 크기
  - **시간** (최근 액세스 시간, 최근 갱신 시간)
  - **i-node 시간** : i-node 구조를 마지막으로 수정한 시간
  - **블록 목록** : 파일의 첫 번째 세그먼트를 가지고 있는 디스크 블록의 번호목록
  - **간접 목록** : 다른 블록들의 목록



> ### Q) 파일시스템과 디스크 개념을 연결해서 파일 시스템이 필요한 이유를 설명해주세요. 
> 💡 Hint : 파일은 디스크 단위로 이루어져 있는데 디스크는 byte단위로 읽지 못 함.

파일을 블록으로 나누고 블록에 논리적 번호를 구성합니다. 이 파일의 (논리적) 블록을 디스크의 (물리적) 블록에 **디스크 블록 할당 방법을 통해 저장**합니다.
- **연속 할당 (contiguous allocation)**


<img width="500" alt="image" src="https://user-images.githubusercontent.com/67494004/227732366-2ac3f7b5-b140-4c47-941c-be43701c5bd5.png">


-  **연속된 블록에 파일을 할당하는 방법**입니다.
-  **[장점]**
   -  디스크 헤더의 이동을 최소화 할 수 있어 **I/O 성능을 높일 수** 있습니다.
   -  **순차 접근(Sequential Access) 가능**
   -  **직접 접근(Direct Access)이 가능**
-  **[단점]**
   -  파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 **외부 단편화 문제가 발생**합니다.
   -  파일을 저장할 때 **실제 크기를 알 수 없습니다.**
   

**연결 할당 (linked allocation)**


<img width="500" alt="image" src="https://user-images.githubusercontent.com/34755287/57186868-72ac2900-6f21-11e9-94a6-40054c58852b.png">


- 연속 할당의 문제점을 해결하기 위해, **링크드 리스트(linked list) 와 같은 방식으로 파일을 할당**합니다.
- **[장점]** 
  - 새로운 파일을 할당할 때 **비어있는 임의의 블록을 첫 블록으로 선택**합니다,
  - 파일이 커지는 경우 **다른 블록을 할당**해서 **기존의 블록과 연결**만 해주면 되기에 연결 할당은 위치와 상관없이 할당이 가능하므로 **외부 단편화 문제가 없습니다.** (= 디스크 낭비가 없다.)
- **[단점]** 
  - 순차 접근은 가능하지만 **직접 접근은 불가능**합니다.
    - 파일의 블록들은 모두 흩어져 있으므로 시작 **블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없습니다**.
   - **포인터를 저장하는 4 bytes** 이상의 **손해**가 발생합니다. ( *linked list of data blocks* )
     -  각 블록의 마지막에 주소를 저장하는 포인터 공간(4bytes)이 존재하며, 여기서 다음 블록을 가리킴.
     -   마지막 블록의 포인터 공간에는 끝임을 나타내는 값이 저장되어 있음.
   - **중간 블록의 포인터가 끊어지면** 그 이후의 모든 블록에 **접근하지 못한다**는 특징이 있습니다 (낮은 신뢰성)
   - 블록이 **모두 흩어져 있으므로** 디스크 헤더의 움직임이 그 만큼 많이 발생하여 **속도가 느립니다.**
   - 이러한 문제를 해결하기 위해 나온 것이 **FAT**



**색인 할당 (indexed allocation)**
<img width="500" alt="image" src="https://user-images.githubusercontent.com/34755287/57186870-72ac2900-6f21-11e9-8b3b-531b44ea89ce.png">


- 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당, 인덱스 블록이라고 부르는 블록에 **할당된 블록 번호(포인터)를 하나의 블록에 따로 저장**합니다.
  -  파일 당 하나의 인덱스 블록이 존재
- **[장점]**
  - 색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 **직접 접근이 가능**
  - 연속적으로 할당할 필요가 없으므로 **외부 단편화 문제 또한 발생하지 않음.**
    - 색인 할당은 Unix/Linux에서 주로 사용한다. (i-node)

- **[단점]**
  - 작은 크기의 파일인 경우에도 **하나의 블록을 인덱스 블록으로 사용**하기 때문에 **저장 공간이 손실**
  - 하나의 인덱스 블록을 가지고는 **크기가 큰 파일을 저장할 수 없음.**


> ### Q) 파일 시스템의 Super Block 에 대해 설명해주세요.
<img width="679" alt="image" src="https://user-images.githubusercontent.com/67494004/227731344-3b0e4a78-4206-4c6d-83b5-5a17bacdd81a.png">


- UNIX 파일 시스템의 구조는 **부트 블록(Boot Block), 슈퍼 블록(Super Block), I-node(Index node) 블록, 데이터 블록**으로 구성됩니다.

  - **부트 블록** : 부팅 시 필요한 코드를 저장하고 있는 블록
  - **슈퍼 블록** : 전체 파일 시스템에 대한 정보를 저장하고 있는 블록
  - **I-node 블록** : 각 파일이나 디렉터리에 대한 모든 정보를 저장하고 있는 블록
  - **데이터 블록** : 디렉터리별로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장된 블록


- 슈퍼 블록의 특징은
  - **디스크에 저장되는 가장 중요한 정보**를 담고 있는 블록입니다.
    - 디스크의 헤드와 실린더 수, i-node 목록의 헤드, 자유 블록에 대한 정보
  - **파일 시스템이 마운트될 때 맨 처음 읽는 정보**입니다.
  - 슈퍼블록은 모든 블록 그룹에 똑같은 복사본을 갖도록 시스템이 자동으로 생성됩니다.
  - 파일 시스템 손상되었을 때 슈퍼블록을 이용하여 복구 가능합니다.




> ### Q) 블록 단위로 불러오고 나서 흩어져 있는 블록들에 파일을 불러와야 합니다. 파일을 할당하는 방식 중 연결 할당 방식에 대해 설명해주세요.
- 파일을 할당하는 방식은 크게 연속 할당, 불연속 할당으로 나눌 수 있습니다.
연속 할당은 파일을 디스크에 연속되게 저장하는 방식으로 한 번의 탐색으로 많은 양을 전송할 수 있으며 접근성이 좋습니다. 하지만, 외부 단편화가 발생하며, 파일의 크기를 키우기가 어렵습니다. 파일의 커질 가능성을 고려해서 미리 큰 공간을 할당한다면 내부 단편화가 발생할 수도 있습니다.
이러한 문제를 해결하기 위해 불연속 할당이 나왔는데, 불연속 할당은 연결 할당과 색인 할당으로 나눌 수 있습니다. 
- 연결 할당은 링크드 리스트로 구현되어 끊겨버리게 되거나 그 이후부터 다시 확인할 수 없다는 단점을 보완하기 위해, FAT가 나왔습니다.


### FAT(File Allocation Table) 시스템


<img width="500" alt="image" src="https://user-images.githubusercontent.com/34755287/57186869-72ac2900-6f21-11e9-98db-e780d2db15ea.png">


- 다음 블록을 가리키는 포인터들만 모아서 **하나의 테이블(FAT)을 만들어 한 블록에 저장**합니다.
- 기존의 연결 할당 문제점을 대부분 해결합니다.
  - **한 번만 읽으면 직접 접근이 가능**
  - 중간 블록에 문제가 생겨도 FAT를 통해 **그 다음 블록은 여전히 읽을 수 있음**
  - FAT는 매우 중요한 정보이므로 손실 시 복구를 위해 **이중 저장**
  - FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 하는데, 현재는 일반적으로 32bit 크기를 사용 : **FAT32**
    - (이전에는 FAT16, FAT12 등이 있었음)
  

   > ### Q) 파일 할당 시스템도 순서대로 찾아가는 식으로 파일을 탐색, 연결리스트다 보니까 속도가 느린데 이런 부분은 파일 할당 시스템이 어떻게 해결하나요?
   - 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직이는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있습니다.


> ### Q) 어떤 운영체제를 사용하고 계신가요? -> 맥은 어떤 파일 시스템을 사용하나요?
맥은 APFS(Apple File System) 파일 시스템을 사용합니다.
윈도우는 FAT32, Linux는 EXT 사용

### Q) 다양한 파일 시스템 중 제일 잘 알고 있는 파일 시스템에 대해 설명해주세요.

Linux 파일 시스템 Extend File System(EXT) 에 대해 설명해보겠습니다.
**EXT 1**
<img width="500" alt="image" src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*6-hlDl3jIBkmqi0N86mOLw.png">
- inode 수정을 지원하지 않으며, linked list를 통해 free block과 inode를 추적하기 때문에 성능이 저하된다는 문제점이 존재

**EXT 2**
<img width="500" alt="image" src="https://user-images.githubusercontent.com/67494004/227734113-3570b012-6394-4276-9ec6-c5ee2b37c3a2.png">
- EXT2는 부트스트랩 코드가 존재하는 부트블록과 여러 개의 블록 그룹으로 구성됩니다. 그리고 블록 그룹은 다시 6가지 영역(super block, block group descriptor, block bitmap, inode bitmap, inode table, data blocks)으로 구분됩니다.
  

**EXT 3**
-  **directory 검색 성능을 높이기 위해 hash 기반 HTree 기술이 도입**
   -  EXT2는 directory를 단순 연결 리스트로 관리
      -  directory 내의 파일 수가 증가하는 경우 파일 검색 시간 또한 선형적으로 증가 -> **HTree 구조를 도입**하여 directory 내에 **많은 파일이 존재하더라도 상수 시간 안에 접근**
      -  HTree란?
      -  B-Tree와 유사하며 directory indexing을 위한 특수 트리 데이터 구조
      -  filename의 hash를 사용하며 tree는 단일 directory entry를 가리키는 것이 아니라 directory entry들이 저장되어 있는 block을 가리킴
      -  HTree는 최대 2 level이므로 검색은 상수 시간 안에 가능
      -  Hash 값의 마지막 1bit는 hash collision을 나타냄
      -   Hash collision chain의 마지막 block을 제외하고 모든 block은 collision bit가 set 되어 있음.
      -   collision bit가 1인 경우 다음 block을 이어서 검사
  
-  **저널링(journaling) 기능 지원**
   -  시스템 충돌이나 정전과 같은 이벤트로 인해 발생할 수 있는 파**일시스템 손상을 신속하게 복구**하는 기능
      - EXT2에서 충돌이 발생하면 파일시스템 전체를 스캔
      - 데이터를 파일시스템의 실제 영역에 기록하기 전에 해당 정보를 log 영역에 기록하여 시스템이 갑자기 **종료**되더라도 그 **위치를 파악**할 수 있고 파일시스템 **전체를 검사할 필요 X**
- EXT3는 파일시스템과 파일의 최대 크기가 작고 연속적인 데이터 블록에 대해 비효율적인 인덱싱 방식을 사용하는 등 여러 단점이 존재
  
**EXT4**
- 대용량 파일시스템과 파일 크기 지원
- 1EB(=1024∗1024TB) 이상의 볼륨과 16TB 이상의 파일을 지원


> ### Q) File Descriptor 에 대해 설명해주세요.
흔히 **유닉스 시스템에서 모든 것을 파일**이라고 합니다. 일반적인 정규파일부터 디렉토리, 소켓, 파이프, 블록 디바이스, 케릭터 디바이스 등 **모든 객체들을 파일로 관리**합니다. 유닉스 시스템에서 **프로세스가 이 파일들을 접근할 때 파일 디스크립터라는 개념을 이용**합니다.
즉, 유닉스에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, **프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값** 입니다.
프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, **파일 디스크립터(FD)값을 이용해서 파일을 지칭**할 수 있습니다.

  ### Q) File Descriptor VS i-node
  - **파일 디스크립터 : 프로세스에서 열려 있는 파일에 대한 참조**
    - 운영 체제가 파일을 열 때 파일에 할당하는 고유한 식별자
    - 읽기/쓰기 작업에서 파일을 참조하는 데 사용되는 정수 값

  - **inode(인덱스 노드의 줄임말) : 디스크의 파일을 관리하는 데 사용하는 데이터 구조**
    - 소유자, 권한, 타임스탬프와 같은 파일이나 디렉터리에 대한 메타데이터와 구성 요소를 구성하는 디스크의 데이터 블록에 대한 포인터를 저장하는 데이터 구조
    - 파일 시스템에서 파일 및 디렉토리를 관리하고 디스크에 저장된 위치를 추적하는 데 사용



> ### Q) i-node에 파일이 저장되는 방식에 대해 설명해주세요.


<img width="600" alt="image" src="https://velog.velcdn.com/images%2Fredgem92%2Fpost%2Fd9bcaff6-2ffc-4404-a40e-a892f490b769%2Fimage.png">


i-node는 15개의 블록으로 제한되어 있습니다.
먼저 **Direct Block에 12개의 주소만 저장**합니다. 
- 블록의 크기는 최대 4KB니까 파일의 공간은 48KB 밖에 되지 않지만 우리가 사용하는 모든 프로그램이나 파일은 이 크기를 넘어섭니다. 
- 파일의 용량이 클수록 데이터 정보를 담는 **Direct Block의 크기를 늘리면 비효율적**입니다. 
- 하여 이를 Single Indirect, Double Indirect, Triple Indirect로 처리합니다. 


각 Indirect는 4KB의 블록인데, 여기 안에 데이터를 직접 처리하는게 아니라 **특정 블록을 접근할 수 있게 주소를 담고 있습니다.** 이러한 구조를 통해 파일은 비교적 적은 블록을 가지고 있어도 **대량의 데이터를 관리**할 수 있게 됩니다.

  - **Single Indirect** : 4KB / 4byte = 1024개의 데이터 주소
  - **Double Indirect** : Single Indirect의 주소를 1024개
    - 1024 x 1024 x 4KB = 4GB정도의 데이터를 접근
  - **Triple Indirect** : Double Indirect의 주소를 1024개

> ### Q) 유닉스 아이노드 크기가 몇 바이트로 이루어져있는 지 알고 계신가요?
> 💡 Hint : 64byte~128byte 로 구성


 Unix inode의 크기는 **일반적으로 128바이트**입니다. 
이 크기는 **필수 메타데이터를 저장하기에 충분한 공간을 허용하기 때문**입니다. 메모리 사용량 및 디스크 공간의 제약과 함께 **메타데이터에 대한 빠른 접근과 저장공간의 균형을 맞추기 위해 선택**되었습니다. 
- inode 크기
  - 작을수록 
    - 더 많은 파일을 디스크 파티션에 저장
    - 또 너무 작으면 아이노드 정보를 저장할 수 없음
  - 클수록 
    - 더 많은 공간을 차지
    - inode 자체를 저장하는 데 더 많은 공간이 필요하기 때문에 시스템 속도가 느려질 수 있음 -> 즉, 실제 파일을 저장하는 데 사용할 수 있는 공간이 더 적음
  
그러나 **일부 파일 시스템은** 추가 메타데이터 또는 확장 속성을 수용하기 위해 256바이트 또는 512바이트와 같은 **더 큰 크기를 사용**할 수 있습니다.



> ### Q) 섹터 단위가 512byte인데 파일이 412byte라 100byte가 남으면 어떤 문제가 발생하나요?
> 💡 hint : 단편화! 내부단편화/외부단편화

![image](https://user-images.githubusercontent.com/67494004/227765035-b65d822d-d71d-458b-b59c-97477a06482e.png)

**내부 단편화**는 파일에 **필요한 것보다 더 많은 공간이 할당**되어 **파일 자체 내에서 공간이 낭비**될 때 발생합니다. 이 경우 파일은 412바이트에 불과하지만 512바이트의 전체 섹터가 할당됩니다. 즉, 파일 내에 **100바이트의 내부 단편화**가 있음을 의미합니다.

![image](https://user-images.githubusercontent.com/67494004/227765016-34f3bdfa-cf8d-47b8-ae29-c827e699dad1.png)

**외부 단편화**는남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, **남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상** 입니다. 이 경우 412바이트 파일이 포함된 섹터에는 **100바이트의 사용되지 않은 공간**이 있으며, **새 파일을 저장하는 데** 사용할 수 있는 연속 여유 **섹터가 충분하지 않은 경우 외부 단편화에 기여**할 수 있습니다.

시간이 지남에 따라 내부 및 외부 단편화로 인해 운영 체제가 새 파일을 저장할 연속 **여유 공간 블록을 찾기 어려워져 성능이 저하되고 디스크 공간이 낭비**될 수 있습니다. **단편화를 최소화**하기 위해 파일 시스템은 종종 클러스터링 및 **블록 할당 알고리즘**과 같은 기술을 사용하여 공간을 보다 효율적으로 할당하고 낭비되는 공간을 줄입니다.

이미지 및 내용 참고
https://code-lab1.tistory.com/54   
https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-18.-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9
