# Deadlock

### 데드락에 대해 설명해주세요
* 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, 시스템적으로 한정된 자원을 동시에 여러 곳에서 사용하려고 할 때 발생합니다. 데드락은 4가지 조건이 충족이 되어야 발생을 하고, 그 조건에는 상호배제, 점유 대기, 비선점, 순환 대기가 있습니다.

   <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F243E89355714C26E28" width = "900px" height = "500px">
   
   #### Q) 데드락이 발생하는 조건에 대해서 설명해주세요.
   - 데드락은 상호 배제, 점유 대기, 비선점, 순환 대기 4가지 조건이 충족되어야 발생합니다.
      - `상호 배제` : 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
      - `점유 대기` : 최소한 하나의 자원을 점유하고 있으면서, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
      - `비선점` : 이미 할당된 자원을 강제로 빼앗을 수 없다.
      - `순환 대기` : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.    
      
      
      
      > #### Q) 각각의 조건들에 대한 예방 방법을 설명해주세요.
      - 예방을 하기 위해서는 각각의 조건들에 대해 부정을 하면 됩니다.
      - `상호 배제 부정` : 여러 개의 프로세스가 동시에 공유자원을 사용할 수 있게 합니다. 단, 이럴 경우 동기화 문제가 발생할 수 있습니다.
      - `점유 대기 부정` : 프로세스가 실행되기 전에 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나, 자원이 점유되지 않은 상태에서만 자원 요청을 받도록 합니다.
      - `비선점 부정` : 모든 자원에 대한 선점을 허용합니다.
      - `순환 대기 부정` : 자원을 선형으로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 합니다.
   #### Q) 데드락을 해결하기 위한 방법 중 회복에 대해서 설명해주세요.
   - 데드락을 회복하기 위해서는 먼저 데드락을 탐지하는 과정이 필요합니다. 데드락을 탐지하기 위해 은행원 알고리즘을 사용해야 합니다.
      - `은행원 알고리즘` : 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 안정 상태에 들 수 있는지 여부를 검사하는 것입니다. 
   - 이러한 알고리즘을 통해 데드락을 탐지했다면, 프로세스를 1개 이상을 중단 시키거나, 자원을 선점시키는 방식으로 데드락을 회복할 수 있습니다.
   - 이때, 중단 시키는 작업은 프로세스의 부분 결과가 폐기될 수 있고, 회복하기 위해서는 탐지 알고리즘을 계속 수행해주어야 하기 때문에, busy waiting 문제가 발생할 수 있습니다.

   #### Q) 데드락이 발생하는 4가지 조건 중 왜 3 가지 조건을 만족하면 데드락이 발생하지 않는지에 대해서 설명해주세요.
   - 데드락이 발생하기 위한 4가지 조건 중 하나의 조건을 충족하지 않는 다는 것은 어떠한 한 가지 조건에 대해 예방을 했다고 말 할 수 있습니다. 따라서, 데드락이 발생하지 않습니다.

   > #### Q) 자바에서 데드락이 발생할 수 있을까요?
   - 멀티 쓰레드 환경으로 동작하게 하고, 동기화 설계를 잘못해준 경우에 데드락이 발생할 수 있습니다.
   - 이를 이해하기 위하여, synchronized에 대해서 이해 할 필요가 있습니다.
   - synchronized 키워드는 동기화가 필요한 메서드나 코드 블럭 앞에 사용하여 동기화 할 수 있습니다. synchronized로 지정된 임계영역은 한 스레드가 이 영역에 접근하여 사용할 때 lock이 걸림으로써 다른 스레드가 접근을 할 수 없게되고, 해당 스레드가 임계영역의 코드를 실행 후 벗어나게 되면 unlock 상태가 되어 그때서야 대기하고 있던 다른 스레드가 이 임계영역에 접근하여 lock을 걸고 사용할 수 있게 됩니다.
   - 데드락이 발생하는 설계 상의 오류는 `synchronized`안에 `synchronized`를 또 선언 할 경우에 발생합니다.
      ```java
      private static void sum(Node n1, Node n2) {
         // 0부터 9까지 반복한다.
         for (int i = 0; i < 10; i++) {
         // n1에 lock을 건다.
            synchronized (n1) {
            // n2에 lock을 건다.
               synchronized (n2) {
               // 값을 가져와서
               int data = n1.getData();
               // i만큼 더한다.
               n1.setData(data + i);
               // 값을 가져와서
               data = n2.getData();
               // i만큼 더한다.
               n2.setData(data + i);
            }
            }
            // 콘솔 출력
            System.out.println(Thread.currentThread().getName() + " i = " + i);
            // 스레드 1초 대기
            sleep();
         }
      }
      ```
   - 다음과 같은 상황에서 쓰레드가 2개가 있을 때 첫 쓰레드에 n1, n2 두번째 쓰레드에 n2, n1을 넣었다고 했을 때, 멀티 쓰레드에서는 병렬 처리를 하기 때문에, n1과 n2가 동시에 락을 획득하는 상황이 생길 수 있습니다.
   - 동시에 n1과 n2에 락이 걸렸을 때, 다음 스탭에서 첫번째 스레드에서 n2에 접근을 하려고 할 때, n2는 락이 걸려있기 때문에 wait상태가 되고, 이어서 두번째 스레드에서도 n1으로 들어가려고 하니 락이 걸려있어 wait 상태로 빠지게 됩니다.
   - 이렇게 두 스레드는 서로의 lock이 풀리는 것을 기다려야 하는 상황이 발생하는 데드락에 빠지게 되는 것입니다.
   - 따라서, 각각의 노드들에 대한 synchronized를 사용하지 않고, 해당 함수의 접근에 있어서 동기화 처리를 하게 되면 데드락 문제가 발생하지 않습니다.
   > #### Q) synchronized에 대해서 간략하게 설명해주세요.

   ![image](https://tecoble.techcourse.co.kr/static/ff6bf378623f4cbfe190196dcffdc476/1255e/java-monitor.png)
   - 자바의 synchronized 키워드는 스레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다. 즉, 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념입니다.
   - synchronized는 상호 배제를 위해 monitor 기법을 채택하고 있습니다. 여기서 monitor 기법이란, mutex, semaphore 같은 경우에는 직접 lock 변수 혹은 wait, signal을 어떠한 동기화를 위해 직접 명시해야 하는 문제로 인해 개발자가 실수하여 잘못 설계되는 경우가 발생할 수 있습니다. 이를 개선하기 위해 상호 배제를 프로그램으로 구현한 것입니다. 
      ```java
      public static synchronized Instance getInstance() {
         if (Objects.isNull(instance)) {
            instance = new Instance();
         }
         return instance;
      }
      ```
   > #### Q) 현대 운영체제에서는 데드락 문제를 어떻게 해결하고 있는지 선택해주세요.
   - 힌트 : 예방은 자원 문제가 심해서 회피를 선택합니다.
   - 데드락이 드물게 발생을 하게 되면, 데드락을 해결하기 조치가 더 큰 오버헤드를 발생시킬 수 있습니다. 따라서 이를 방지하기 위해 **데드락 무시 기법**을 채택하고 있으며, 교착상태 발생 시 프로세스를 종료하여 재실행하거나, 자원을 선점하여 회복한다고 합니다.
   - 교착상태를 회피하기 위해서는 계속해서 탐지를 해야하는데, 현대의 OS에서는 데드락이 드물게 발생하기 드물게 발생하기도 하고, 자원을 요청할 때마다 시스템의 상태를 판단하고 알고리즘을 돌려야하기 때문에, 현대 시스템에서는 회피 방법 사용 시에 발생하는 오버헤드를 감당하는 시스템이 없다고 합니다.

   #### Q) 데드락이 발생하는 시나리오
   
   ![Image](https://velog.velcdn.com/images%2Fminseojo%2Fpost%2F5cb6568d-be51-42fa-b860-6f02172fbd02%2Fimage.png)
   
   - 데드락이 발생하는 시나리오 중에서 가장 유명한 시나리오는 식사하는 철학자 입니다. 식사하는 철학자의 진행 방식은 다음과 같습니다.
      1. 일정 시간 생각을 한다.
      2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
      3. 오른쪽 포크가 사용 가능해질 때가지 대기한다. 만약 사용 가능하다면 집어든다.
      4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
      5. 오른쪽 포크를 내려놓는다.
      6. 왼쪽 포크를 내려놓는다.
      7. 다시 1번으로 돌아간다.
   - 이럴 경우 2번을 진행을 하게 되면 모든 철학자들은 포크를 집어들고 있고, 모든 철학자가 오른쪽 포크를 들기 위해 3번 상태에서 머무르는 데드락 상황이 발생합니다.
   
   #### 사진,내용에 대한 출처
   - https://jwprogramming.tistory.com/12
   - https://kadosholy.tistory.com/123
   - https://tecoble.techcourse.co.kr/post/2021-10-23-java-synchronize/
   - https://velog.io/@minseojo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90-%EB%AC%B8%EC%A0%9C
