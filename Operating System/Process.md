# Process

[프로세스, 스레드가 무엇인가요? ](#프로세스,스레드가-무엇인가요?)


[프로세스 메모리 구조에 대해 설명해주세요.](#프로세스-메모리-구조에-대해-설명해주세요.)


[멀티프로세스, 멀티스레드에 대해 설명해주세요.](#멀티프로세스,-멀티스레드에-대해-설명해주세요.)


### 프로세스,스레드가 무엇인가요?
<img width="600" src="https://user-images.githubusercontent.com/67494004/225917972-cbde23cc-a3ff-46eb-84e3-297ec565378c.png">


 - 프로세스의 관련 개념인 프로그램부터 설명해보겠습니다. **프로그램은 디스크에 저장된 실행파일 그 자체**입니다. 이 프로그램을 **더블클릭이나 명령어를 통해 실행**하게 되면 **메모리에 적재가 되고 이는 프로세스**가 됩니다. **프로세스의 실행 단위를 스레드** 라고 합니다.
    #### Q) 프로세스의 상태에 대해 설명해주세요.
    <img width="600" src="https://user-images.githubusercontent.com/67494004/226166890-e2589251-2b55-4c92-9d8f-622283953b0d.png">

    - **new, ready, running, waiting, terminated** 상태가 있습니다. 
    - `New` : 프로그램이 실행되어 프로세스를 생성중인 상태
    - `Ready` : CPU에 할당되기를 기다리는 상태
    - `Running` : 실행되고 있는 상태
    - `Waiting` : 입출력이나 다른 이벤트가 발생하기를 기다리는 상태
    - `Terminated` : 프로세스가 종료된 상태
    
    
      #### Q-1) Memory가 부족할 경우, Process는 어떠한 상태로 변하나요?
      - 메모리가 부족하면 프로세스가 **"blocked" 상태로 변경**되어 더 많은 메모리를 사용할 수 있을 때까지 기다립니다. 프로세스가 **충분한 메모리를 확보**할 수 있으면 **"Ready" 상태로 다시 전환**하고 실행을 계속할 수 있습니다.
       - Memory가 부족한 경우
         - 프로세스가 사용 가능한 것보다 더 많은 메모리를 할당하려고 시도할 때
         -  운영 체제가 사용 가능한 리소스를 소비하는 다른 프로세스로 인해 충분한 메모리를 제공할 수 없을 때 발생
          
 
    > Q) **program → process가 될 때 운영체제가 하는 일**
    - 프로그램이 실행되면 운영체제는 프로그램을 **메모리에 할당**하고 이는 프로세스가 됩니다. 
      - 1. **메모리 할당** : 프로그램 주소공간을 저장하기 위해 프로세스에 대한 메모리 공간을 할당
      - 2. **프로세스 ID 할당** : 고유한 PID를 할당
      - 3. **프로세스 테이블 생성** : 운영체제는 프로세스에 대한 정보를 저장하기 위해 프로세스 테이블에 항목을 만듭니다. (프로세스 상태, 프로그램 카운터, 레지스터값 등 ...)
      - 4. 시스템 리소스 설정 : 운영체제는 파일 설명자, 입/출력 장치 및 프로세스 실행에 필요할 수 있는 기타 리소스와 같은 시스템 리소스를 설정
      - 5. 프로그램 코드 및 데이터 복사 : 프로그램 코더와 데이터를 프로세스의 할당된 메모리 공간에 복사
      - 6. 실행 시작 : 운영체제는 프로그램 카운터를 프로그램 코드의 시작 부분으로 설정하여 프로세스 실행을 시작


    #### Q) Process와 Thread 의 가장 큰 차이점에 대해 설명해주세요.
    - **프로세스**는 **독립적인 실행 단위**로 독립된 메모리 공간을 할당받습니다.
    반면 **스레드**는 프로세스 내의 실행단위로 **타 스레드들과 자원을 공유**한다는 특징이 있습니다.
      #### Q-1) 그럼 프로세스는 독립적인 실행 단위면, 서로의 자원을 공유할 수 없나요?
      - 기본적으로 각각의 프로세스는 독립된 메모리 공간을 할당받기 때문에 프로세스는 **다른 프로세스의 자료에 접근할 수 없습니다**. 하지만 다른 프로세스 간에 **데이터를 공유하고 상호작용하기 위한 기술**을 활용하면 **접근할 수 있습니다.** 이를 **IPC** 라고 부르며 공유 메모리, 메시지 큐, 파이프 등의 방식이 있습니다.
        - **공유 메모리**는 메모리를 공유하여 두 개 이상의 프로세스가 데이터를 공유하는 방식입니다.
        - **메시지 큐**는 메시지를 주고 받을 수 있는 큐를 통해 프로세스 간 통신을 수행하는 기법입니다.
        - 2주차에 각 방법 깊게 다룰 예정

    #### Q) 크롬의 탭은 프로세스일까요, 스레드일까요? explorer 의 탭도 설명해주세요.
    - **`크롬의 탭은 프로세스, 익스플로러는 스레드`** 입니다.
    - **프로세스는 각각 독립된 자원을 할당**받지만, **스레드는 자원을 공유**하기 때문에 한 스레드가 종료되면 같은 프로세스 내의 모든 스레드가 종료됩니다.


      - 즉, **스레드**는 하나의 탭이 종료되면 **다른 탭도 종료**가 되기 때문에 이는 익스플로러에 해당하고
      - **프로세스**는 하나의 탭이 종료되어도 **다른 탭은 사용 가능**하기에 이는 크롬에 해당합니다.
      - 크롬은 탭마다 PID를 가지고 있으며, 각 탭마다 랜더링 정보나 기타 데이터를 따로 관리합니다. 그로 인해 메모리를 많이 잡아먹기도 합니다.


     #### Q) 좀비 프로세스와 고아 프로세스
     - `좀비 프로세스` : **프로세스가 종료되었지만 프로세스 테이블에 여전히 실행 중**임을 나타내는 항목이 있는 프로세스 입니다.
        - 자식 프로세스가 상태 신호 없이 죽거나, 부모 프로세스가 먼저 죽은 경우입니다. 
        - 자식 프로세스가 종료되면 운영 체제는 부모 프로세스에 신호를 보내 자식 프로세스가 종료되었음을 알립니다. 
        - 그런 다음 <mark>부모 프로세스는 wait() 시스템 호출을 사용</mark>하여 자식의 종료 상태를 검색하고 프로세스 테이블에서 해당 항목을 제거합니다.


     - `고아 프로세스` : **부모 프로세스가 자식 프로세스보다 먼저 종료**되면 자식 프로세스는 부모가 없는 프로세스입니다.
        - 운영 체제는 대리 부모 역할을 하는 초기화 프로세스에 고아 프로세스를 할당
        - 그런 다음 **init 프로세스**는 wait() 시스템 호출을 사용하여 고아 프로세스를 회수하고 프로세스 테이블에서 해당 항목을 제거
   
#### 사진&내용 출처
[Process -> Program](https://flylib.com/books/en/4.443.1.19/1/)


[프로세스 상태](https://nostressdev.tistory.com/16) 

---

### 프로세스 메모리 구조에 대해 설명해주세요.
* 운영체제는 각각의 프로세스에게 메모리를 할당하는데,
<br> 위에서부터 스택(Stack), 힙(Heap), 데이터영역(BSS Segment, Data Segment), 코드영역(Code Segment)으로 나눠집니다.

![image](https://user-images.githubusercontent.com/110760593/226155831-d0df44ec-ab99-41d2-b47b-ed67458af7df.png)

- 동적할당은 런타임 단계에서 메모리를 할당받는 것이며 스택과 힙으로 나누어집니다.
  - 스택은
    - 위에서 부터 아래로 메모리 주소가 채워집니다.
    - 지역변수, 매개변수, 실행함수 및 반환값이 저장되는 메모리 공간으로, 함수가 호출될 때마다 환경 정보가 계속해서 저장됩니다.
    - 컴파일 시 크기가 결정되는데, 함수가 함수를 호출하는 등에 따라 런타임 시에도 크기가 변경되는 동적인 특징을 가집니다.
    - 참고로 재귀 함수가 호출될 때에는 매 번 새로운 스택 프레임이 사용되기 때문에 함수 내 변수 집합이 
    <br> 다른 함수의 인스턴스 변수를 방해하지 않습니다.
  - 힙은
    - 아래에서 위로 메모리 주소가 채워집니다.
    - 동적으로 할당되는 변수들을 저장하며 런타임 시에 크기가 결정됩니다.
    - new(), malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료구조의 경우 Heap 영역을 사용합니다. 
    <br> 예를들어 vector는 내부적으로 Heap 영역을 사용합니다.
    - 힙 메모리는 스택 메모리보다 사용할 수 있는 메모리 공간이 크고 사용이 유연하다는 장점이 있습니다.
    - 그러나 포인터로 메모리에 접근하기 때문에 중간에 한 단계를 더 거쳐 데이터의 Read/Write가 스택에 비해 느립니다.
  
- 정적할당은 컴파일 단계에서 메모리를 할당하는 것이며, 데이터 영역과 코드영역으로 나뉘어서 저장됩니다.
  - 데이터 영역은
    - 전역변수, 정적 변수, 배열 등이 저장되는 공간으로 BSS segment 영역과 Data segment 영역으로 나뉩니다.
      - BSS segment는 전역 변수, 정적 변수 중 0으로 초기화 되었거나, 어떤 값으로도 초기화 되지 않은 변수들이 이 곳에 할당됩니다.
      - Data segment는 전역 변수, 정적 변수 중 0이 아닌 값으로 초기화 된 변수가 이 곳에 할당됩니다.
  - 코드 영역(Code Segment)은
    - 소스코드(프로그램 명령) 자체를 구성하는 메모리 영역입니다.
    - 프로그램 실행 도중에 작성한 코드가 변경되는 불상사가 생기면 안되기 때문에 읽기만 가능합니다.
  
  #### Q) 스택이 힙보다 더 빠른 이유는 무엇인가요? (스택에 할당된 변수에 접근하는 것이 힙 할당 변수에 접근하는 것보다 빠른 이유)
  - 스택은 CPU에 의해 관리되며 이미 할당된 공간을 사용하는 것이고, 힙은 OS에 의해 할당해서 사용하는 공간이므로
  <br> 스택의 속도가 힙보다 더 빠릅니다.
  - 컴파일러는 주어진 프로그램을 컴파일하는 과정에서 스택에 할당될 변수들의 정확한 크기와 할당 순서를 알 수 있어,
  <br> 스택 기준 상대위치(offset)를 정확하게 알 수 있습니다.
  <br> 따라서 스택에 할당된 변수들은 add(스택 바닥 주소 + offset) 이후 load만으로 변수의 값을 읽어들일 수 있습니다.
  - 힙은 OS에 의해 관리되어, 어셈블리를 컴파일하는 단계에서는 이 변수가 힙의 어떤 offset에 할당될지 알 수 없습니다.
  <br> 따라서 OS에서 할당받은 주소를 스택에 할당된 변수에 저장해두고,
  <br> 실제로 힙에 접근할 때는 add -> load로 변수의 주소값을 읽어들인 뒤 다시 그 주소를 load해야 합니다.
  <br> 즉 포인터로 메모리에 접근하기 때문에 중간에 한 단계를 더 거쳐 데이터의 Read/Write가 스택에 비해 느립니다.
  
  #### Q) 프로세스의 메모리 구조를 나누는 이유는 무엇인가요?
  - 한 프로그램이 실행될 때 각각의 변수, 함수, 클래스 등이 호출되고 해제되는 시기는 전부 다르기 때문에, 
  <br> 각각의 특성에 따라 메모리를 효율적으로 사용하기 위해서 메모리 구조를 나누는 것입니다.
  - 예를 들어 함수 내에서 한 번 사용되는 지역 변수가 프로그램 끝까지 메모리에 남아있게 되면 메모리가 낭비됩니다.

  #### Q) 운영체제도 프로세스 주소공간을 가지나요?
  - 메모리에 상주하는 운영체제 부분을 커널이라고 하는데, 커널도 프로세스와 유사하게
  <br> 코드, 데이터, 스택으로 구성된 주소공간을 가집니다.
  - 단 프로세스 주소 공간보다 더 강력한 보안성을 가진다는 특성이 있습니다.
  
  #### Q) 정적변수와 전역변수의 차이는 무엇인가요?
  - 전역변수와 정적변수는 생명 주기는 동일하지만 두 변수가 접근할 수 있는 범위(scope)에서 차이가 존재합니다.
  - 전역변수는 해당 프로그램(실행 파일)의 어떤 파일과 함수에도 접근이 가능하지만 
  <br> 정적 변수는 해당 변수가 선언된 파일이나 함수 내에서만 접근이 가능합니다.

  #### Q) 스레드는 프로세스의 어떤 부분을 공유하고 공유하지 않나요?
  - 스레드는 프로세스 내의 스택 메모리 영역을 제외한 다른 메모리 영역 (code / data / heap)은 다른 스레드와 공유합니다. 

  #### Q) 스택을 따로 할당하는 이유는 무엇인가요?
  - 스택은 함수 호출 시 전달되는 인자, 복귀할 주소 값, 함수 내 선언하는 변수 등을 저장하는 메모리 공간입니다. 
  <br> 각각의 스레드가 독립적인 함수 호출이 가능하려면 스택 공간이 독립적이어야 합니다.
  <br> 따라서 스레드가 독립적인 실행 흐름을 가질 수 있도록 독립된 스택을 할당하는 것입니다.
  
  #### Q) 초기화하지 않은 변수들은 어디에 저장되나요? 그리고 두 영역을 구분하는 이유는 무엇인가요?
  - 전역 변수, 정적 변수 중 0으로 초기화 되었거나 어떠한 값으로도 초기화 되어 있지 않은 변수들은 BSS segment 영역에 할당됩니다.
  - 전역 변수, 정적 변수 중 0이 아닌 값으로 초기화 된 변수 Data segment 메모리 영역에 할당됩니다.
  - 초기화 되지 않은 변수들은 프로그램이 실행될 때 해당 영역만 잡아주고 그 값을 저장할 필요가 없지만,
  <br> 초기화 된 값은 그 값을 저장하고 있어야 합니다. 
  <br> 따라서 BSS segment의 변수들이 많아져도 프로그램이 실행 코드 사이즈 영역을 늘리지 않아도 되므로
  <br> 효율성 측면에서 따로 구분해서 저장합니다.
  
  #### Q) CPU가 명령을 확인하고 코드를 실행할 때 어떤 일들이 일어나나요?
  - CPU는 메모리에서 명령어를 계속 가져와서 수행합니다. 
  <br> 이 때 프로그램 카운터에 CPU가 다음으로 실행할 명령어의 주소가 들어있습니다.
  - CPU가 해당 주소에서 명령어를 가져 온 뒤, 프로그램 카운터를 증가시켜 그 다음 실행할 명령어 주소를 대입합니다.
  - 가저온 명령을 실행한 뒤 다시 위 과정을 반복합니다.

  #### Q) 스레드 주소 공간은 어떻게 구성되어 있을까요?
  - 스레드 주소 공간은 스레드 사적 공간과 스레드들 간 공유 공간으로 나누어집니다.
  - 스레드 사적 공간은 다시 스레드 코드, 스레드 로컬 스토리지, 스레드 사용자 스택과 스레드 커널 스택으로 구성되고,
  <br> 스레드 공유 공간은 프로세스에 선언된 코드, 데이터, 힙 공간으로 구성됩니다.
    - 스레드 코드 영역 : 스레드가 실행할 작업이 들어있습니다. 프로세스 코드 영역에 있는 다른 모든 함수를 호출 할 수 있습니다.
    - 스레드 데이터 영역 : 개별 스레드 전용 공간엔 스레드 로컬 스토리지와 프로세스에 의해 공유되는 변수 공간이 있습니다.
    - 스레드 힙 : 모든 스레드가 동적 할당을 받는 공간으로 프로세스 힙 공간을 사용합니다.
    - 스레드 스택 :  프로세스 스택의 일부분을 할당합니다.
    #### Q-1) 스레드 제어 블록은 어디에 저장되나요?
    - 스레드의 실행 상태 정보는 스레드 컨텍스트라고 하며 이는 CPU 레지스터 값으로 스레드 제어블록(TCB)에 저장되어 있습니다.
    - TCB는 커널 영역에 만들어지고, 커널에 의해서 관리됩니다.
  
  #### Q) 리눅스 개발자는 스레드와 프로세스를 구분짓지 않는데 그 이유는 무엇인가요?
  - 프로세스가 스레드를 만드는 과정은, 프로세스가 자식 프로세스를 만드는 과정과 시스템 내에선 크게 다르지 않습니다.
  - 스레드는 부모 프로세스 PCB 정보를 모두 가지지만 PCB 내 대부분의 정보가 포인터로 이루어져 있고,
  <br> 몇몇 구조체에서만 스레드임을 알기 위한 다른 정보가 들어 있습니다.
  - 스레드를 세미 프로세스 또는 가벼운 프로세스(Light-weight process)라고도 합니다.
  - 참고로 리눅스에서는 스레드를 생성하면 PID는 부모 프로세스와 같지만 스레드로서 고유 SPID를 갖습니다. (ps -T)


---


### 멀티프로세스, 멀티스레드에 대해 설명해주세요. 
- 멀티프로세스란, 하나의 프로그램을 여러 개의 프로세스로 구성해서, 각 프로세스가 하나의 작업을 수행할 수 있도록 하는 작업입니다.  
- 멀티스레드란, 하나의 프로세스 안에서 두 개 이상의 스레드가 작업을 수행하는 것입니다.

  #### Q) 멀티프로세스와 멀티스레드의 각각의 장단점을 설명해주세요.
  - 멀티프로세스의 장점 : 
     - CPU의 낭비되는 시간을 줄일 수 있습니다. (CPU 사용률을 높일 수 있습니다.)
     - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.
  - 멀티스레드의 장점 : 
     - 운영체제가 시스템 자원을 효율적으로 관리할 수 있습니다.
     - 멀티 프로세스보다 적은 메모리 공간을 가집니다.
     - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 
     - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간 통신의 부담이 줄어듭니다.
  - 공통적인 단점 :
    - context switching 시 오버헤드가 발생합니다.
  - 멀티프로세스의 단점 : 
     - 메모리가 많이 필요하며, context 스위칭 시 스레드에 비해 오버헤드가 큽니다.
  - 멀티스레드의 단점 : 
     - 동기화 문제가 발생합니다. (동기화 관리를 잘해주어야 합니다.)
     - 하나의 스레드 장애로 전체 스레드가 종료 될 위험이 존재합니다.

  #### Q) 싱글스레드와 멀티스레드의 차이를 설명해주세요.
  
  - 싱글스레드
     - 하나의 프로세스 안에서 하나의 스레드만 사용하는 것입니다.
     - 메인 스레드만으로 작업을 처리합니다. 스레드가 하나라서 작업을 차례대로 처리합니다. 
     - (ex) A,B 작업이 있다고 하면 A작업을 다 처리해야 B작업을 처리할 수 있습니다.

  - 멀티스레드 : 
     - 하나의 프로세스 안에서 두개 이상의 스레드를 사용하는 것입니다. 
     - 메인 스레드 외의 추가적인 스레드를 이용해서 병렬적으로 작업 처리가 가능합니다. 
     - (ex) A,B 작업이 있다고 하면 A->B->A 식으로 처리를 하는 것이 가능합니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088416-530596ec-f817-4629-99e8-23f6228fd30a.png)

  - 추가 조사 : 싱글스레드와 멀티스레드의 장단점
  - 멀티스레드의 장점 
     - (1) 응답성 
        - 프로그램 일부 중단되거나 긴 작업을 수행해야 하는 프로그램을 마주하더라도 프로그램 수행이 계속되어 사용자에게 응답 반환이 지속적으로 가능합니다. => 응답성이 좋습니다. 
     - (2) 경제성 
        - 프로세스 내 자원, 메모리 공유하기에 메모리 공간, 자원 소모가 줄어듭니다. 
     - (3) 병렬성 
        - CPU를 여러 개 사용하는 구조에서는 각 스레드가 다른 프로세서에서 병렬적으로 수행될 수 있어, 병렬성이 극대화됩니다. 
  - 멀티스레드의 단점 
     - (1) 시간, 비용
        - context switching, 동기화로 인한 오버헤드 발생 => 싱글코어 멀티스레드는 느립니다.
     - (2) 동기화 문제
        - 공유 자원 동시 접근 경우를 처리해주어야 합니다.

  - 싱글스레드의 장점 
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 동기화 문제 X
        - 동기화 처리 필요가 없습니다. 또한 동기화 처리 비용도 발생하지 않습니다.

  - 싱글스레드의 단점  
     - (1) 연산량이 많은 작업 시 비효율 발생
        - 연산이 오래 걸리는 작업이 있으면, 해당 작업 끝낼 때까지 기다려야 다음 작업 할 수 있습니다.
     - (2) 에러 처리를 못하는 경우 멈춥니다.
        - 멀티 스레드는 에러 발생 시 새 스레드를 만들어 이를 처리하지만, 싱글 스레드는 대처하지 못할 수 있습니다.

  #### Q) 멀티스레드와 멀티프로세스가 각각 유리한 경우의 예시를 설명해주세요.
  > 둘의 가장 큰 차이는 메모리 공유 여부입니다. 
  - 다른 메모리 침범을 하지 않아야 하는 병렬적인 경우에는 멀티 프로세스를 이용하는 것이 좋습니다. (ex) 미사일 시스템  
  - 멀티스레드는 사용자 응답성이 중요한 프로그램에 사용하는 것이 좋습니다. (ex) 채팅 프로그램

  #### Q) 스레드에서의 동시성과 병렬성에 대해 설명해주세요.
  - 동시성 : 논리적인 동시성 개념입니다. context switching이 빠르게 일어나면서 프로그램이 동시에 수행되는 것처럼 보이는 것입니다. (실제 동시 실행은 아닙니다.)
     - (ex) 하나의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  - 병렬성 : 물리적 동시성 개념입니다. 실제로 동시에 여러 작업이 수행되는 현상입니다. 
     - (ex) 여러개의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088487-03354b30-f9dd-46ab-b034-b4197b5ffc12.png)

  #### 사진 & 내용 출처 
  - https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread-t5gv4udj
  - https://sas-study.tistory.com/446

