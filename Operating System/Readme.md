# 운영체제
### 프로세스,스레드가 무엇인가요?
<img width="600" src="https://user-images.githubusercontent.com/67494004/225917972-cbde23cc-a3ff-46eb-84e3-297ec565378c.png">


 - 프로세스의 관련 개념인 프로그램부터 설명해보겠습니다. **프로그램은 디스크에 저장된 실행파일 그 자체**입니다. 이 프로그램을 **더블클릭이나 명령어를 통해 실행**하게 되면 **메모리에 적재가 되고 이는 프로세스**가 됩니다. **프로세스의 실행 단위를 스레드** 라고 합니다.
    #### Q) 프로세스의 상태에 대해 설명해주세요.
    
    <img width="659" alt="스크린샷 2023-03-19 오후 6 46 36" src="https://user-images.githubusercontent.com/67494004/226166856-2c339854-e9c5-4771-a94e-1df745c6d6cf.png"><br></br>
    
    - **new, ready, running, waiting, terminated** 상태가 있습니다. 
    - `New` : 프로그램이 실행되어 프로세스를 생성중인 상태
    - `Ready` : CPU에 할당되기를 기다리는 상태
    - `Running` : 실행되고 있는 상태
    - `Waiting` : 입출력이나 다른 이벤트가 발생하기를 기다리는 상태
    - `Terminated` : 프로세스가 종료된 상태
    
    
      #### Q-1) Memory가 부족할 경우, Process는 어떠한 상태로 변하나요?
      - 메모리가 부족하면 프로세스가 **"blocked" 상태로 변경**되어 더 많은 메모리를 사용할 수 있을 때까지 기다립니다. 프로세스가 **충분한 메모리를 확보**할 수 있으면 **"Ready" 상태로 다시 전환**하고 실행을 계속할 수 있습니다.
       - Memory가 부족한 경우
         - 프로세스가 사용 가능한 것보다 더 많은 메모리를 할당하려고 시도할 때
         -  운영 체제가 사용 가능한 리소스를 소비하는 다른 프로세스로 인해 충분한 메모리를 제공할 수 없을 때 발생
          > Q) Active & Suspend 차이
          ![process-state](https://user-images.githubusercontent.com/67494004/226166890-e2589251-2b55-4c92-9d8f-622283953b0d.png)
 <br></br>  
 
    > Q) **program → process가 될 때 운영체제가 하는 일**
    - 프로그램이 실행되면 운영체제는 프로그램을 **메모리에 할당**하고 이는 프로세스가 됩니다. 
      - 1. **메모리 할당** : 프로그램 주소공간을 저장하기 위해 프로세스에 대한 메모리 공간을 할당
      - 2. **프로세스 ID 할당** : 고유한 PID를 할당
      - 3. **프로세스 테이블 생성** : 운영체제는 프로세스에 대한 정보를 저장하기 위해 프로세스 테이블에 항목을 만듭니다. (프로세스 상태, 프로그램 카운터, 레지스터값 등 ...)
      - 4. 시스템 리소스 설정 : 운영체제는 파일 설명자, 입/출력 장치 및 프로세스 실행에 필요할 수 있는 기타 리소스와 같은 시스템 리소스를 설정
      - 5. 프로그램 코드 및 데이터 복사 : 프로그램 코더와 데이터를 프로세스의 할당된 메모리 공간에 복사
      - 6. 실행 시작 : 운영체제는 프로그램 카운터를 프로그램 코드의 시작 부분으로 설정하여 프로세스 실행을 시작


    #### Q) Process와 Thread 의 가장 큰 차이점에 대해 설명해주세요.
    - **프로세스**는 **독립적인 실행 단위**로 독립된 메모리 공간을 할당받습니다.
    반면 **스레드**는 프로세스 내의 실행단위로 **타 스레드들과 자원을 공유**한다는 특징이 있습니다.
      #### Q-1) 그럼 프로세스는 독립적인 실행 단위면, 서로의 자원을 공유할 수 없나요?
      - 기본적으로 각각의 프로세스는 독립된 메모리 공간을 할당받기 때문에 프로세스는 **다른 프로세스의 자료에 접근할 수 없습니다**. 하지만 다른 프로세스 간에 **데이터를 공유하고 상호작용하기 위한 기술**을 활용하면 **접근할 수 있습니다.** 이를 **IPC** 라고 부르며 공유 메모리, 메시지 큐, 파이프 등의 방식이 있습니다.
        - **공유 메모리**는 메모리를 공유하여 두 개 이상의 프로세스가 데이터를 공유하는 방식입니다.
        - **메시지 큐**는 메시지를 주고 받을 수 있는 큐를 통해 프로세스 간 통신을 수행하는 기법입니다.
        - 2주차에 각 방법 깊게 다룰 예정

    #### Q) 크롬의 탭은 프로세스일까요, 스레드일까요? explorer 의 탭도 설명해주세요.
    - **`크롬의 탭은 프로세스, 익스플로러는 스레드`** 입니다.
    - **프로세스는 각각 독립된 자원을 할당**받지만, **스레드는 자원을 공유**하기 때문에 한 스레드가 종료되면 같은 프로세스 내의 모든 스레드가 종료됩니다.


      - 즉, **스레드**는 하나의 탭이 종료되면 **다른 탭도 종료**가 되기 때문에 이는 익스플로러에 해당하고
      - **프로세스**는 하나의 탭이 종료되어도 **다른 탭은 사용 가능**하기에 이는 크롬에 해당합니다.
      - 크롬은 탭마다 PID를 가지고 있으며, 각 탭마다 랜더링 정보나 기타 데이터를 따로 관리합니다. 그로 인해 메모리를 많이 잡아먹기도 합니다.


     #### Q) 좀비 프로세스와 고아 프로세스
     - `좀비 프로세스` : **프로세스가 종료되었지만 프로세스 테이블에 여전히 실행 중**임을 나타내는 항목이 있는 프로세스 입니다.
        - 자식 프로세스가 상태 신호 없이 죽거나, 부모 프로세스가 먼저 죽은 경우입니다. 
        - 자식 프로세스가 종료되면 운영 체제는 부모 프로세스에 신호를 보내 자식 프로세스가 종료되었음을 알립니다. 
        - 그런 다음 <mark>부모 프로세스는 wait() 시스템 호출을 사용</mark>하여 자식의 종료 상태를 검색하고 프로세스 테이블에서 해당 항목을 제거합니다.


     - `고아 프로세스` : **부모 프로세스가 자식 프로세스보다 먼저 종료**되면 자식 프로세스는 부모가 없는 프로세스입니다.
        - 운영 체제는 대리 부모 역할을 하는 초기화 프로세스에 고아 프로세스를 할당
        - 그런 다음 **init 프로세스**는 wait() 시스템 호출을 사용하여 고아 프로세스를 회수하고 프로세스 테이블에서 해당 항목을 제거
   
#### 사진&내용 출처
[Process -> Program](https://flylib.com/books/en/4.443.1.19/1/)


[프로세스 상태](https://nostressdev.tistory.com/16) 

---

### 프로세스 메모리 구조에 대해 설명해주세요.
* 운영체제는 각각의 프로세스에게 메모리를 할당하는데,
<br> 위에서부터 스택(Stack), 힙(Heap), 데이터영역(BSS Segment, Data Segment), 코드영역(Code Segment)으로 나눠집니다.

![image](https://user-images.githubusercontent.com/110760593/226155831-d0df44ec-ab99-41d2-b47b-ed67458af7df.png)

- 동적할당은 런타임 단계에서 메모리를 할당받는 것이며 스택과 힙으로 나누어집니다.
  - 스택은
    - 위에서 부터 아래로 메모리 주소가 채워집니다.
    - 지역변수, 매개변수, 실행함수 및 반환값이 저장되는 메모리 공간으로, 함수가 호출될 때마다 환경 정보가 계속해서 저장됩니다.
    - 컴파일 시 크기가 결정되는데, 함수가 함수를 호출하는 등에 따라 런타임 시에도 크기가 변경되는 동적인 특징을 가집니다.
    - 참고로 재귀 함수가 호출될 때에는 매 번 새로운 스택 프레임이 사용되기 때문에 함수 내 변수 집합이 
    <br> 다른 함수의 인스턴스 변수를 방해하지 않습니다.
  - 힙은
    - 아래에서 위로 메모리 주소가 채워집니다.
    - 동적으로 할당되는 변수들을 저장하며 런타임 시에 크기가 결정됩니다.
    - new(), malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료구조의 경우 Heap 영역을 사용합니다. 
    <br> 예를들어 vector는 내부적으로 Heap 영역을 사용합니다.
    - 힙 메모리는 스택 메모리보다 사용할 수 있는 메모리 공간이 크고 사용이 유연하다는 장점이 있습니다.
    - 그러나 포인터로 메모리에 접근하기 때문에 중간에 한 단계를 더 거쳐 데이터의 Read/Write가 스택에 비해 느립니다.
  
- 정적할당은 컴파일 단계에서 메모리를 할당하는 것이며, 데이터 영역과 코드영역으로 나뉘어서 저장됩니다.
  - 데이터 영역은
    - 전역변수, 정적 변수, 배열 등이 저장되는 공간으로 BSS segment 영역과 Data segment 영역으로 나뉩니다.
      - BSS segment는 전역 변수, 정적 변수 중 0으로 초기화 되었거나, 어떤 값으로도 초기화 되지 않은 변수들이 이 곳에 할당됩니다.
      - Data segment는 전역 변수, 정적 변수 중 0이 아닌 값으로 초기화 된 변수가 이 곳에 할당됩니다.
  - 코드 영역(Code Segment)은
    - 소스코드(프로그램 명령) 자체를 구성하는 메모리 영역입니다.
    - 프로그램 실행 도중에 작성한 코드가 변경되는 불상사가 생기면 안되기 때문에 읽기만 가능합니다.
  
  #### Q) 스택이 힙보다 더 빠른 이유는 무엇인가요? (스택에 할당된 변수에 접근하는 것이 힙 할당 변수에 접근하는 것보다 빠른 이유)
  - 스택은 CPU에 의해 관리되며 이미 할당된 공간을 사용하는 것이고, 힙은 OS에 의해 할당해서 사용하는 공간이므로
  <br> 스택의 속도가 힙보다 더 빠릅니다.
  - 컴파일러는 주어진 프로그램을 컴파일하는 과정에서 스택에 할당될 변수들의 정확한 크기와 할당 순서를 알 수 있어,
  <br> 스택 기준 상대위치(offset)를 정확하게 알 수 있습니다.
  <br> 따라서 스택에 할당된 변수들은 add(스택 바닥 주소 + offset) 이후 load만으로 변수의 값을 읽어들일 수 있습니다.
  - 힙은 OS에 의해 관리되어, 어셈블리를 컴파일하는 단계에서는 이 변수가 힙의 어떤 offset에 할당될지 알 수 없습니다.
  <br> 따라서 OS에서 할당받은 주소를 스택에 할당된 변수에 저장해두고,
  <br> 실제로 힙에 접근할 때는 add -> load로 변수의 주소값을 읽어들인 뒤 다시 그 주소를 load해야 합니다.
  <br> 즉 포인터로 메모리에 접근하기 때문에 중간에 한 단계를 더 거쳐 데이터의 Read/Write가 스택에 비해 느립니다.
  
  #### Q) 프로세스의 메모리 구조를 나누는 이유는 무엇인가요?
  - 한 프로그램이 실행될 때 각각의 변수, 함수, 클래스 등이 호출되고 해제되는 시기는 전부 다르기 때문에, 
  <br> 각각의 특성에 따라 메모리를 효율적으로 사용하기 위해서 메모리 구조를 나누는 것입니다.
  - 예를 들어 함수 내에서 한 번 사용되는 지역 변수가 프로그램 끝까지 메모리에 남아있게 되면 메모리가 낭비됩니다.

  #### Q) 운영체제도 프로세스 주소공간을 가지나요?
  - 메모리에 상주하는 운영체제 부분을 커널이라고 하는데, 커널도 프로세스와 유사하게
  <br> 코드, 데이터, 스택으로 구성된 주소공간을 가집니다.
  - 단 프로세스 주소 공간보다 더 강력한 보안성을 가진다는 특성이 있습니다.
  
  #### Q) 정적변수와 전역변수의 차이는 무엇인가요?
  - 전역변수와 정적변수는 생명 주기는 동일하지만 두 변수가 접근할 수 있는 범위(scope)에서 차이가 존재합니다.
  - 전역변수는 해당 프로그램(실행 파일)의 어떤 파일과 함수에도 접근이 가능하지만 
  <br> 정적 변수는 해당 변수가 선언된 파일이나 함수 내에서만 접근이 가능합니다.

  #### Q) 스레드는 프로세스의 어떤 부분을 공유하고 공유하지 않나요?
  - 스레드는 프로세스 내의 스택 메모리 영역을 제외한 다른 메모리 영역 (code / data / heap)은 다른 스레드와 공유합니다. 

  #### Q) 스택을 따로 할당하는 이유는 무엇인가요?
  - 스택은 함수 호출 시 전달되는 인자, 복귀할 주소 값, 함수 내 선언하는 변수 등을 저장하는 메모리 공간입니다. 
  <br> 각각의 스레드가 독립적인 함수 호출이 가능하려면 스택 공간이 독립적이어야 합니다.
  <br> 따라서 스레드가 독립적인 실행 흐름을 가질 수 있도록 독립된 스택을 할당하는 것입니다.
  
  #### Q) 초기화하지 않은 변수들은 어디에 저장되나요? 그리고 두 영역을 구분하는 이유는 무엇인가요?
  - 전역 변수, 정적 변수 중 0으로 초기화 되었거나 어떠한 값으로도 초기화 되어 있지 않은 변수들은 BSS segment 영역에 할당됩니다.
  - 전역 변수, 정적 변수 중 0이 아닌 값으로 초기화 된 변수 Data segment 메모리 영역에 할당됩니다.
  - 초기화 되지 않은 변수들은 프로그램이 실행될 때 해당 영역만 잡아주고 그 값을 저장할 필요가 없지만,
  <br> 초기화 된 값은 그 값을 저장하고 있어야 합니다. 
  <br> 따라서 BSS segment의 변수들이 많아져도 프로그램이 실행 코드 사이즈 영역을 늘리지 않아도 되므로
  <br> 효율성 측면에서 따로 구분해서 저장합니다.
  
  #### Q) CPU가 명령을 확인하고 코드를 실행할 때 어떤 일들이 일어나나요?
  - CPU는 메모리에서 명령어를 계속 가져와서 수행합니다. 
  <br> 이 때 프로그램 카운터에 CPU가 다음으로 실행할 명령어의 주소가 들어있습니다.
  - CPU가 해당 주소에서 명령어를 가져 온 뒤, 프로그램 카운터를 증가시켜 그 다음 실행할 명령어 주소를 대입합니다.
  - 가저온 명령을 실행한 뒤 다시 위 과정을 반복합니다.

  #### Q) 스레드 주소 공간은 어떻게 구성되어 있을까요?
  - 스레드 주소 공간은 스레드 사적 공간과 스레드들 간 공유 공간으로 나누어집니다.
  - 스레드 사적 공간은 다시 스레드 코드, 스레드 로컬 스토리지, 스레드 사용자 스택과 스레드 커널 스택으로 구성되고,
  <br> 스레드 공유 공간은 프로세스에 선언된 코드, 데이터, 힙 공간으로 구성됩니다.
    - 스레드 코드 영역 : 스레드가 실행할 작업이 들어있습니다. 프로세스 코드 영역에 있는 다른 모든 함수를 호출 할 수 있습니다.
    - 스레드 데이터 영역 : 개별 스레드 전용 공간엔 스레드 로컬 스토리지와 프로세스에 의해 공유되는 변수 공간이 있습니다.
    - 스레드 힙 : 모든 스레드가 동적 할당을 받는 공간으로 프로세스 힙 공간을 사용합니다.
    - 스레드 스택 :  프로세스 스택의 일부분을 할당합니다.
    #### Q-1) 스레드 제어 블록은 어디에 저장되나요?
    - 스레드의 실행 상태 정보는 스레드 컨텍스트라고 하며 이는 CPU 레지스터 값으로 스레드 제어블록(TCB)에 저장되어 있습니다.
    - TCB는 커널 영역에 만들어지고, 커널에 의해서 관리됩니다.
  
  #### Q) 리눅스 개발자는 스레드와 프로세스를 구분짓지 않는데 그 이유는 무엇인가요?
  - 프로세스가 스레드를 만드는 과정은, 프로세스가 자식 프로세스를 만드는 과정과 시스템 내에선 크게 다르지 않습니다.
  - 스레드는 부모 프로세스 PCB 정보를 모두 가지지만 PCB 내 대부분의 정보가 포인터로 이루어져 있고,
  <br> 몇몇 구조체에서만 스레드임을 알기 위한 다른 정보가 들어 있습니다.
  - 스레드를 세미 프로세스 또는 가벼운 프로세스(Light-weight process)라고도 합니다.
  - 참고로 리눅스에서는 스레드를 생성하면 PID는 부모 프로세스와 같지만 스레드로서 고유 SPID를 갖습니다. (ps -T)

---


### 멀티프로세스, 멀티스레드에 대해 설명해주세요. 
- 멀티프로세스란, 하나의 프로그램을 여러 개의 프로세스로 구성해서, 각 프로세스가 하나의 작업을 수행할 수 있도록 하는 작업입니다.  
- 멀티스레드란, 하나의 프로세스 안에서 두 개 이상의 스레드가 작업을 수행하는 것입니다.

  #### Q) 멀티프로세스와 멀티스레드의 각각의 장단점을 설명해주세요.
  - 멀티프로세스의 장점 : 
     - CPU의 낭비되는 시간을 줄일 수 있습니다. (CPU 사용률을 높일 수 있습니다.)
     - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.
  - 멀티스레드의 장점 : 
     - 운영체제가 시스템 자원을 효율적으로 관리할 수 있습니다.
     - 멀티 프로세스보다 적은 메모리 공간을 가집니다.
     - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 
     - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간 통신의 부담이 줄어듭니다.
  - 공통적인 단점 :
    - context switching 시 오버헤드가 발생합니다.
  - 멀티프로세스의 단점 : 
  - 멀티스레드의 단점 : 
     - 동기화 문제가 발생합니다. (동기화 관리를 잘해주어야 합니다.)
     - 하나의 스레드 장애로 전체 스레드가 종료 될 위험

  #### Q) 싱글스레드와 멀티스레드의 차이를 설명해주세요.
  - 싱글스레드
     - 하나의 프로세스 안에서 하나의 스레드만 사용하는 것입니다.
     - 메인 스레드만으로 작업을 처리합니다. 스레드가 하나라서 작업을 차례대로 처리합니다. 
     - (ex) A,B 작업이 있다고 하면 A작업을 다 처리해야 B작업을 처리할 수 있습니다.
  - 멀티스레드 : 
     - 하나의 프로세스 안에서 두개 이상의 스레드를 사용하는 것입니다. 
     - 메인 스레드 외의 추가적인 스레드를 이용해서 병렬적으로 작업 처리가 가능합니다. 
     - (ex) A,B 작업이 있다고 하면 A->B->A 식으로 처리를 하는 것이 가능합니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088416-530596ec-f817-4629-99e8-23f6228fd30a.png)

  - 추가 조사 : 싱글스레드와 멀티스레드의 장단점
  - 멀티스레드의 장점 
     - (1) 응답성 
        - 프로그램 일부 중단되거나 긴 작업 수행해야 하는 프로그램을 마주하더라도 프로그램 수행이 계속되어 사용자에게 응답 반환이 지속적으로 가능합니다. => 응담성이 좋습니다. 
     - (2) 경제성 
        - 프로세스 내 자원, 메모리 공유하기에 메모리 공간, 자원 소모가 줄어듭니다. 
     - (3) 병렬성 
        - CPU를 여러 개 사용하는 구조에서는 각 스레드가 다른 프로세서에서 병렬적으로 수행될 수 있어, 병렬성이 극대화됩니다. 
  - 멀티스레드의 단점 
     - (1) 시간, 비용
        - context switching, 동기화로 인한 오버헤드 발생 => 싱글코어 멀티스레드는 느립니다.
     - (2) 동기화 문제
        - 공유 자원 동시 접근 경우를 처리해주어야 합니다.

  - 싱글스레드의 장점 
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 동기화 문제 X
        - 동기화 처리 필요가 없습니다. 또한 동기화 처리 비용도 발생하지 않습니다.

  - 싱글스레드의 단점  
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 연산량이 많은 작업 시 비효율 발생
        - 연산이 오래 걸리는 작업이 있으면, 해당 작업 끝낼 때까지 기다려야 다음 작업 할 수 있습니다.
     - (3) 에러 처리를 못하는 경우 멈춥니다.
        - 멀티 스레드는 에러 발생 시 새 스레드를 만들어 이를 처리하지만, 싱글 스레드는 대처하지 못할 수 있습니다.

  #### Q) 멀티스레드와 멀티프로세스가 각각 유리한 경우의 예시를 설명해주세요.
  > 둘의 가장 큰 차이는 메모리 공유 여부입니다. 
  - 다른 메모리 침범을 하지 않아야 하는 병렬적인 경우에는 멀티 프로세스를 이용하는 것이 좋습니다. (ex) 미사일 시스템  
  - 멀티스레드는 사용자 응답성이 중요한 프로그램에 사용하는 것이 좋습니다. (ex) 채팅 프로그램

  #### Q) 스레드에서의 동시성과 병렬성에 대해 설명해주세요.
  - 동시성 : 논리적인 동시성 개념입니다. context switching이 빠르게 일어나면서 프로그램이 동시에 수행되는 것처럼 보이는 것입니다. (실제 동시 실행은 아닙니다.)
     - (ex) 하나의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  - 병렬성 : 물리적 동시성 개념입니다. 실제로 동시에 여러 작업이 수행되는 현상입니다. 
     - (ex) 여러개의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088487-03354b30-f9dd-46ab-b034-b4197b5ffc12.png)

  #### 사진 & 내용 출처 
  - https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread-t5gv4udj
  - https://sas-study.tistory.com/446

---


### PCB와 Context Switching
<img src = "https://user-images.githubusercontent.com/74203371/226113159-6f77bb2d-029a-44fc-b7c4-037874e4cddb.png" width = "300px" height = "500px">

* Process Control Block의 약자인 PCB는 **프로세스의 메타 정보들을 저장해두는 커널에 있는 자료구조** 입니다. PCB에 저장되는 프로세스 메타정보에는 다음과 같이 8개의 메타 정보를 저장합니다.
  1. `Process ID` : PID(Process Identification Number) 주로 PID 라고 줄여서 부릅니다.
  : 프로세스 고유 식별 번호
  2. `Process State`(프로세스 상태)
  : 프로세스의 현재 상태(생성, 준비, 실행, 대기, 종료)를 기억 시킵니다.
  3. `Program Counter`(계수기)
  : 다음에 실행되는 명령어의 주소를 기억시킵니다.
  4. `Process Priority`(스케줄링 정보)
  : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억시킵니다.
  5. `CPU Registers`
  : 프로세스의 레지스터 상태를 저장하는 공간 등, CPU 내 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 등이 갖고 있는 값을 기억시킵니다.
  6. `Owner`(계정 정보)
  : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억시킵니다.
  7. `기억장치 관리 정보`
  : 프로그램이 적재될 기억 장치의 시작 지점(베이스 레지스터), 종료 지점(한계 레지스터), 페이지 테이블 등의 정보를 기억시킵니다.
  8. `입출력 정보`
  : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억시킵니다.

<img src = "https://user-images.githubusercontent.com/74203371/226113194-1107b326-cca0-447f-ac3c-cb85c6e6ac7f.png" width = "1065px" height = "550px">

* Context Switching 이란 **CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB로 부터 읽어 준비 상태 큐에 있던 프로세스를 실행 상태로 옮기는 것** 을 말합니다.   
Context Switching 은 주로 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가 시간(Time Quantum)을 모두 소모(타이머 인터럽트 == 타입아웃 인터럽트 발생) 하거나, I/O 입출력을 위해 대기해야 하는 경우 발생합니다.

  #### Q) Context Switching이 일어날 때, 캐시 관련해서도 프로세스와 스레드의 처리 방법이 다르다고 알고 있습니다. 이를 설명해주세요.
  - 프로세스는 메모리 영역은 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 이 때, 캐시는 참조 지역성의 원리에 의해서 저장이 되는데 참조 지역성의 원리는 시간 지역성과 공간 지역성 두 개로 나뉩니다. 이때, 시간 지역성은 '최근에 접근했던 메모리 공간에 다시 접근하려는 경향' 을 의미하며, 공간 지역성은 '접근한 메모리 공간 근처를 접근하려는 경향' 을 의미합니다.   
**프로세스는 컨텍스트 스위칭이 발생할 때, 독립적인 메모리 영역을 가지고 있기 때문에 메모리 공간 자체가 변경이 일어나게 되는데, 이럴 경우 캐시 메모리의 캐시 히트가 떨어져서 캐시 메모리를 비워줘야 합니다.**
그러나 스레드의 메모리 영역은 프로세스와 동일한 영역으로 구성되어 있지만 code, data, heap 영역을 공유하고, stack 영역만 독립적으로 가지고 있습니다. 따라서, **공유된 데이터들을 사용하여 캐시 히트가 프로세스에 비해 많이 낮아지지 않기 때문에, 캐시 메모리를 비우지 않아도 된다는 장점이 있습니다.**

  #### Q) 프로세스는 여러개의 스레드를 가지고 있는데, 이 스레드들에 대한 정보를 어떻게 가지고 있는가
  - **스레드에 대한 관리는 스레드 제어 블록(TCB)에서 관리를 할 수 있습니다.** 이때, TCB는 시스템에서 생성된 스레드를 나타냅니다. TCB에는 다음과 같은 정보가 저장되어 있습니다.
    1. `Thread ID`
    2. `Thread Status`
    3. `CPU 정보 (PC, Register)`
    4. `Thread Priority`
    5. `스레드의 생성을 트리거한 프로세스를 가리키는 포인터`
    6. `스레드에서 만든 스레드를 가리키는 포인터`
  
    스레드는 커널 영역에서 실행되어야 합니다. 이때 `LWP(Light Weight Process)` 라는 용어가 등장합니다. LWP는 운영 체제에 따라 의미를 다르게 두고 있습니다. 
리눅스의 경우 사용자 레벨 에서의 스레드와 프로세스는 구분이 가능하지만, 스레드가 실행되기 위해서는 커널 영역으로 올라와야하고, 커널 영역에서 cpu해당 스레드를 봤을 때는, 작은 프로세스를 처리한다는     의미로 LWP 를 사용하고 있습니다.   
대부분의 운영체제에서는 사용자 영역 내에서의 스레드는 커널 영역으로 스레드가 이동이 되어서 실행이 되어야 합니다. 이때, 사용자 영역에서 커널 영역으로 스레드를 이동시키는데 이를 도와주는 영역을 LWP     로 사용하고 있습니다. 이때 스레드 간 LWP로 이동되기 위해서 각 스레드끼리 경쟁이 발생하는데, 이를 `PCS(Process-contention scope)` '프로세스 경쟁 범위'라고 하고, LWP로 이동하고 나서도     CPU에 매핑되기 위해서도 스케줄링이 필요합니다. 이러한 것을 `SCS(System Contention Scope)` '시스템 경쟁 범위' 라고 합니다.

    #### Q) 프로세스와 스레드는 Context Switching이 발생할 때 어떤 차이가 있는가
    - 프로세스는 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 따라서 Context Swtiching이 발생할 때, 독립적인 메모리를 포함하여, 캐시 메모리를 비워줘야 해서 스레드에 비해 상대적으로 많은 오버헤드가 발생합니다.
    이와 달리 스레드는 code, data, heap 영역을 공유하고 stack 영역만 독립적으로 가지고 있기 때문에, 캐시 메모리를 비우지 않아도 되고 프로세스에 비해 상대적으로 적은 오버헤드가 발생합니다.
  
  #### Q) Context Switching 에서 프로세스 수행 중에 입출력 상태로 전환되어서 대기 상태로 전환 되는데, CPU를 어떻게 하는 것이 효율적인가?
  - Context Switching 에서 입출력 인터럽트가 발생하게 되면 실행 상태에 있던 프로세스는 대기 상태로 전환됩니다. 이때, CPU 스케줄러에 의해서 해당 프로세스의 자원은 반환됩니다. 이후 CPU가 입출력 인터럽트의 완료를 기다리는 동안 준비 상태 큐에 있는 프로세스 중에서 스케줄링 알고리즘에 따라 실행 상태로 들어가고, 대기 상태에 있던 프로세스는 입출력 작업이 완료되게 되면 다시 준비상태 큐로 들어갑니다.

    #### Q) Context Switching이 인터럽트가 발생할 때만 발생하는가?
    - Context Switching은 다음과 같은 상황에 발생합니다.
      1. 멀티태스킹(Multitasking)
      : 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아가며 수행된다.
      2. 인터럽트 핸들링(Interrupt handling)
      : I/O Request, time slice expired, fork a child, wait for an interrupt
      3. 사용자와 커널 모드 전환(User and kernel mode switching)   
      
      따라서, **모든 상황에서 인터럽트가 발생하므로 인터럽트가 발생할 때에만 발생한다고 할 수 있습니다.** 

      #### Q) 인터럽트는 무조건 들어오는 순서대로 처리를 하는가?
      - 아닙니다. **CPU는 인터럽트를 우선순위에 따라 처리할 수 있습니다.** NMI(Non-Maskable interrupt) 가 발생한 경우 CPU는 해당 인터럽트 부터 처리합니다. 여기서 NMI는 무시될 수 없는 interrupt 입니다. 몇몇 심각한 사건(정전, 하드웨어 고장 등 어찌할 수 없는 오류)등이 해당됩니다.   
많은 컴퓨터에서는 프로그래머블 인터럽트 컨트롤러(PIC : Programmable Interrupt Controller)라는 하드웨어를 사용하여 인터럽트 요청들의 우선순위를 판별합니다.

  
  > Q) 프로세스 컨트롤 블록이 어떤 자료구조로 관리 되는지 알고 있는가
    
  - PCB는 **Doubly Linked List 방식으로 관리**됩니다.
    PCB의 List Head에 PCB들이 생성될 때마다 붙게 됩니다. 주소 값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이합니다.   
    > ~연결 리스트의 구조를 사용함으로써 삽입 `O(1)` 은 용이하다고 생각되지만 (항상 list의 헤드에 붙이기 때문에 위치를 알고 있음.) 삭제에 있어서는 해당 PCB의 위치를 찾고 `O(n)` 연결을 끊는 것 `O(1)` 이기 때문에, 삭제는 용이한지 잘 모르겠습니다..ㅠ 그냥 연결리스트와 배열과 비교를 했을 때 연결 리스트의 탐색은 제외하고 삽입 삭제만 바라봤을 때의 대해서 얘기한거겠죠?~ 동윤님 답변으로 해결되었습니다! `node.prev.next = node.next;`

  > Q) Context Switching 시에 주소공간에 대한 캐시 처리가 어떻게 이루어지는지 설명해주세요.
  
  - TLB를 이해하기 전에 먼저 페이지 테이블을 이해 할 필요가 있습니다.
  기존의 프로세스들을 메모리에 적재할 때, 순차적으로 적재를 하게 되면 단편화 문제가 발생하기 때문에, 이를 방지하기 위해서 가상 메모리 기법이 생겼고, 가상 메모리 기법은 세그멘테이션과 페이징 기법으로 나눌 수 있습니다.   
  가상 메모리 기법으로 분할 된 메모리의 페이지들은 페이지 테이블에서 관리를 하게 되는데, 메모리에 실제 주소를 참조하기 위해서는 
    1. 페이지 테이블에 한번 접근(fetch)
    2. 페이지 테이블을 기반으로 실제 메모리로 접근 (Memory Access)

    와 같은 과정이 필요한데, 실행할 때마다 같은 table에 속한 메모리 주소를 찾고 다시 메인 메모리에 접근해야 하는 불필요한 일이 발생합니다.  
    이런 메모리의 접근을 줄이기 위해서 TLB가 등장했고, TLB는 page table의 임시저장 캐시 역할을 합니다. TLB는 L3 캐시에 위치해있습니다. 이때 TLB에는 최근에 읽었던 변환될 물리 주소를 매핑해서 저장을합니다. 따라서 **TLB를 활용하면 한 프로세스 내의 다른 스레드를 Context Switching 하는 경우 invalid가 발생하지 않아, 주소 공간을 참조하는데 하드웨어 적으로 이점**을 볼 수 있고, **프로세스가 Context Switching을 하게 되는 경우, kernel 주소 공간을 제외한 모든 영역을 invalid 하기 때문에, 스레드와 달리 손해**를 보게 됩니다.
    
    #### 사진 & 내용 출처 
    - https://velog.io/@jaypyon/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9DPCB%EC%9D%B4%EB%9E%80
    - https://afteracademy.com/blog/what-is-context-switching-in-operating-system/
    - https://spurdev.tistory.com/13
    - https://velog.io/@gothae/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-PCB%EC%99%80-Context-Switching
---


### Process Sheduling 알고리즘에는 어떤 것들이 있나요?

- CPU 스케줄링은 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업이라고 할 수 있으며, FCFS, SJF, 라운드로빈 등의 알고리즘들이 있습니다.

    #### Q) 단기, 장기 , 중기 스케줄러가 무엇인가요?

     - 장기스케줄러 :
     
        - **어떤 프로세스를 준비큐에 넣을지** 결정하는 일을 담당한다.(프로세스의 상태 : new -> ready)
        
     - 단기스케줄러 :
     
        -  **장기스케줄러에 의해 선별된 작업중 어떤작업을 해야할지 고르는 일**을 담당한다.(프로세스의 상태 : ready -> running -> waiting -> ready)
        
     - 중기스케줄러 :
     
        - 메모리에 올라온 작업이 CPU가 감당하기힘든 상태가되어 시스템성능이 저하될수있는데 이를 해결하기위해 **적재된 프로세스의 수를 동적으로 조절하는일**을 담당한다.(프로세스의 상태 : ready-> suspended)   
        

        > Q) 현재 CPU에서 장기스케줄러를 사용하고있나요? 사용하고있지않다면 그이유는 무엇인가요?
        
        - 사용하고있지않습니다. 10개의 준비된 프로세스중 메모리에 적재할수있는것이 6개라고 가정했을때 선별하는것이 장기스케줄러인데 현재는 메모리의 크기도 커지기도했고, 가상메모리 관리 덕분에 메모리가 무한인것처럼 사용할수있어 준비된 10개의 프로세스를 모두 적재할수있기 때문입니다.  

        #### Q) 중기 스케줄러 동작방식에 대해 설명해주세요
        - 장기스케줄러에 의해 프로세스를 적재했는데 CPU가 감당하기 힘든상태가 되어 우선순위가 가장 낮거나 일정시간동안 활성되지않은 프로세스중 일부 메모리를 디스크의 스왑영역에 저장합니다. 이로인해 프로세스가 중지(suspended)상태가 됩니다. 장기스케줄러와 동일한이유로 현재 중기스케줄러는 사용되지않습니다.
        
        #### Q) 장기 스케줄러와 단기스케줄러의 실행속도는 얼마나 차이가 날까요?
        - 장기스케줄러는 수십초, 수분단위로 호출되어 단기스케줄러보다 느린속도이고 단기스케줄러는 스케줄링 알고리즘에 따라 ms이하의 시간단위로 매우빈번하게 호출되므로 수행속도가 충분히 빨라야합니다. 


    #### Q) 선점형 / 비선점형 스케줄러는 무엇인가요?

     - 선점형 스케줄러 :
        - CPU를 선점하고있는 프로세스를 교체할수있는 스케줄링 방식 

     - 비선점형 스케줄러 :
        - CPU를 선점하고있는 프로세스가 종료될때까지 교체할수없는 스케줄링 방식

        #### Q) 선점형 / 비선점형 알고리즘의 종류는 무엇이있나요?
        - 선점형 알고리즘에는 라운드로빈, 멀티레벨큐, 멀티레벨피드백큐 등이 있습니다.
        - 비선점형 알고리즘에는 SJF, HRN 등이 있습니다.

    #### Q) FCFS 알고리즘 사용시 문제되는점이 있을까요?
    
    ![image](https://user-images.githubusercontent.com/59333182/226124597-2328cdf0-e03c-4329-91cd-db06102e2cbe.png)
    
    - 위 그림과같이 작업 평균처리시간이 A=100, B=10, C=10 이 소요되는 작업이 차례로 들어온경우 작업 평균반환시간이 늦어지는 문제가있으며, convoy effect를 야기할수있습니다.

        #### Q) 위의 예에서 B,C같은 프로세스처럼 처리시간이 오래걸리는 작업이 먼저 도착해서 B,C가 오래기다리게 되는현상을 부르는 용어는 무엇인가요?
        - 호위 효과(convoy effect) 라고합니다. 짧은시간동안만 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의 종료를 기다리는 현상을 의미합니다.  


    #### Q) 라운드로빈은 어떤 스케줄링기법인지 말씀해주세요.
    - 작업마다 타임슬라이스를 할당받아 CPU를 선점하고, 타임슬라이스가 끝나면 다음작업으로 전환하는 방식으로  시분할 시스템에서 중요할수있는 응답시간을 개선할수있는 알고리즘입니다. 
    
    
        #### Q) 그럼 라운드로빈은 왜 등장하게 된건가요?
        - 시분할 컴퓨터의 등장으로 시스템과 원활하게 상호작용 하기위해 스케줄링 알고리즘을 평가할때  '응답시간(작업이 도착해서 처음 스케줄될때까지의 시간 - 도착시간)'이라는 기준도 중요해지면서 효율적으로 시스템과 상호작용해 **응답시간을 개선하고 CPU시간을 공정하게 할당하기위해서** 등장했습니다.
        
            #### Q) 잔여시간이 긴 프로세스가 선점하지 못한채로 머무르게 되는 현상은 무엇인가요?
            - 기아상태

        #### Q) 라운드로빈의 타임슬라이스는 어느정도로 잡아야하나요?
        - 타임슬라이스가 짧을수록 작업의 응답시간은 좋아질수있지만, 너무 짧으면 context switching 비용이 전체 성능에 영향을 주게되고 타임슬라이스가 너무 길면 작업의 응답시간이 길어질수있습니다.
            
            
        #### Q) 일반적으로 라운드로빈시 타임슬라이스의 권장 할당량이 어느정도인지 아시나요?
        - 일반적으로는 작업별로 타임슬라이스 대비 context switching 비용을 따져봐야하지만 대부분 현대 운영체제들은 10~100msec로 할당합니다.   
         
 
    #### Q) 우선순위 스케줄링에서 기아현상을 해결하기위한 방법이 어떤것이있나요?
    - 주기적으로 모든작업의 우선순위를 상향하는 방식이있습니다. 이렇게되면 프로세스가 굶지않는다는것을 보장받습니다.   
     다만 얼마나 자주 상향시킬것인지?에대해 생각해봐야합니다. 주기가 너무 크면 긴 실행시간을 가진 작업은 굶을수있고, 너무 작으면 I/O bound같은 대화형작업이 CPU를 적절하게 선점할수 없게됩니다. 
 
    #### Q) 스케줄링기법중 멀티레벨 큐와 멀티레벨 피드백큐가 있는데, 둘다 아시는내용을 설명해주세요 
    
    - 멀티레벨 큐 : 
    2개이상의 특정 스케줄링 규칙을 따르는 스케줄링 큐로 구성되는 방식입니다. 각 프로세스를 특정기준(우선순위 혹은 기타속성)에 따라 적절한 대기열에 할당합니다  멀티프로세서 환경에서 단일큐 스케줄링의 단점인 동기화문제를 고려하지않아도 되고 캐시친화적이라는 장점이있지만 일부 CPU가 유휴상태가 될수있는등 작업의 불균형문제가 있습니다.
    
    예를들어, 2개의CPU가 작업중이고 4개의 작업이 있다고 가정할때, 아래와같습니다.     
    
    ![image](https://user-images.githubusercontent.com/59333182/226152668-8b37362c-922c-4c82-9132-86e5eedf5094.png)   
    
    각 큐에서 라운드로빈을 실행한다는 가정하에 아래와 같은 스케줄을 얻을수있습니다.    
    
    ![image](https://user-images.githubusercontent.com/59333182/226152791-fb44c08e-7f3e-4d3e-849f-76910e65c6f7.png)
    
    작업 A 하나로 B와 D보다 2배의 CPU를 차지하게되며, **더 심한경우 Q0에 있는 작업들만 먼저 끝나게 되면 아래와같이 1개의 CPU가 유휴상태가 될수있습니다.**
    
    ![image](https://user-images.githubusercontent.com/59333182/226152837-94b386ad-bff0-460d-bf02-09b7e404790b.png)   
    
    ![image](https://user-images.githubusercontent.com/59333182/226152849-bedbb22e-4f09-4fb5-97f6-3f6f412dfad8.png)
    
    - 멀티레벨 피드백 큐 :
    2개이상의 큐로 구성되며 각각 다른우선순위가 배정되고,각 **큐에남아있는 작업을 확인해서 작업을 이동시켜서(migration) 위에서 얘기했던 작업의 불균형문제를 해소할수있는 방식**입니다. 대부분의 MLFQ들은 우선순위가 높은 큐는 보통 짧은 타임슬라이스가 주어지고, 우선순위가 낮은큐는 긴 타임슬라이스를 가지게되며, 일정주기를 가지고 **우선순위를 상향시켜 기아문제를 해결**하기도합니다.
    
    **둘의 가장 큰 차이점은 큐에 있는작업을 이동할수있는지 없는지가 되겠습니다.**

    #### Q) 프로세스 관리가 필요한 이유는무엇일까요?
    - 멀티프로그래밍이 지향하는것이 CPU이용률을 최대한 높히는건데, 이때 시스템자원을 효율적으로 사용하기위해서 관리가 필요합니다.  
    
    #### Q) 스레드 스케줄링은 어떻게 되나요?
    - 스레드 라이브러리의 기능을통해 제어합니다. 동일한 프로세스내에 있는 스레드들끼리는 우선순위에 따라 스케줄링되지만 라이브러리마다 프로그래머가 스레드의 우선순위를 변경할수도 있습니다. 
    
    #### Q) 각 자원의 우선순위, CPU대기시간 등의 내용들은 어디에 저장될까요?
    - PCB에 Process Priority 라는 공간에 적재됩니다.

    #### Q) CPU가 여러개일때의 스케줄링 기법에대해 설명해주세요
    - 일반적으로 대칭 다중처리라 불리는 각 프로세서가 스스로 스케줄링할수있는 방식으로 접근합니다. 큐 하나를 공통으로 사용하는 방식과, 프로세서별 큐를 가지는 방식이있습니다. 
    - 멀티프로세서 환경에서는 **동기화문제**를 신경써줘야합니다. 여러 CPU들이 동시에 사용하는 큐가 있다고 가정하면 동시성 문제가 생길수있기때문입니다. 이로인해 큐를 하나만사용하는 단일 큐 스케줄링은 멀티프로세서 환경에서 락을 삽입해야하기때문에 확장성이 결여되고, 성능이 저하될수있습니다. 반면 멀티큐 스케줄링에서는 작업이 각각 독립적으로 스케줄되기때문에 동기화 문제를 피할수 있습니다.   
    
  
    - **캐시친화성**도 고려해야합니다.    
    
    ![image](https://user-images.githubusercontent.com/59333182/226159280-97bfaffb-f4d2-4ffa-a81c-560f10150d4d.png)

    먼저 설명드릴점은 cpu에서 프로세스가 실행될때 프로세스는 해당 cpu캐시와 TLB에 상태정보를 올려놓게 되고 이 일부정보로 인해 **같은 CPU에서 실행되면 더 빨리 실행**될수있습니다. 
    
    ![image](https://user-images.githubusercontent.com/59333182/226157747-6e3a0f1a-c2e0-492a-a1f0-a70a6f606677.png)
    
    위와 같이 단일큐가 있고 4개의 CPU가 있다고 가정해보겠습니다. 각 CPU는 큐 하나를 공유해서 작업을 선택하기때문에 하나의 큐에있는 A,B,C,D,E는 **여러 cpu에 나누어져 실행**하게되어 아래와 같은 그림상태가 됩니다.
 
   ![image](https://user-images.githubusercontent.com/59333182/226157954-a2f601bc-80a1-423b-b0d6-86bd42af2961.png)
   
   하나의 작업이 여러 CPU에서 실행되기때문에 캐시친화적이지 않다고볼수있습니다. 물론 단일큐도 이문제를 해결하기위해 가능한 동일한 CPU에서 하나의 작업이 실행되도록 시도하지만 구현 자체가 복잡하고 이 자체가 비용일수있습니다. 
   
  멀티 큐 스케줄링 기법은 CPU 개수가 증가할수록 큐의 개수도 증가할수 있으며,  이문제를 해결합니다. 2개의 CPU와 4개의 작업이 있다고 가정해보면 아래그림과 같습니다.   
  
  ![image](https://user-images.githubusercontent.com/59333182/226158524-856bd338-493b-4320-afbf-0e1123df6de4.png)

각 큐는 스케줄링 정책이 있을것이고 라운드로빈이라고 가정해보면 스케줄은 아래와같이 생성될수있습니다.   

![image](https://user-images.githubusercontent.com/59333182/226158549-ff0faa66-f297-4fe7-8d05-7c14b5ce0f81.png)   
A,B,C,D 각각의 작업은 하나의 CPU에서 고정적으로 실행되어 캐시친화적이라고 볼수있습니다. 

정리하자면 일반적으로 큐하나를 여러 CPU에서 공통으로 사용하는방식, CPU별 큐를 가지게되는 멀티큐 스케줄링방식을 사용하게되며 이는 각각 장단점이 있으며 **동기화, 캐시친화성, 작업의 불균형(피드백 큐같이 이동하는방식으로 해결)** 을 고려해야합니다. 



#### 사진,내용에 대한 출처
- https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/07-cpu-sched.pdf 스케줄링 알고리즘 
- https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/08-cpu-sched-mlfq.pdf 멀티레벨 피드백 큐
- https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/10-cpu-sched-multi.pdf 멀티프로세서 스케줄링시 고려해야할점

---


### 임계구역 문제가 무엇인 지 설명해주세요.

---


### 데드락에 대해 설명해주세요
* 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, 시스템적으로 한정된 자원을 동시에 여러 곳에서 사용하려고 할 때 발생합니다. 데드락은 4가지 조건이 충족이 되어야 발생을 하고, 그 조건에는 상호배제, 점유 대기, 비선점, 순환 대기가 있습니다.

   <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F243E89355714C26E28" width = "900px" height = "500px">
   
   #### Q) 데드락이 발생하는 조건에 대해서 설명해주세요.
   - 데드락은 상호 배제, 점유 대기, 비선점, 순환 대기 4가지 조건이 충족되어야 발생합니다.
      - `상호 배제` : 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
      - `점유 대기` : 최소한 하나의 자원을 점유하고 있으면서, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
      - `비선점` : 이미 할당된 자원을 강제로 빼앗을 수 없다.
      - `순환 대기` : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.
      > Q) 각각의 조건들에 대한 예방 방법을 설명해주세요.
      - 예방을 하기 위해서는 각각의 조건들에 대해 부정을 하면 됩니다.
      - `상호 배제 부정` : 여러 개의 프로세스가 동시에 공유자원을 사용할 수 있게 합니다. 단, 이럴 경우 동기화 문제가 발생할 수 있습니다.
      - `점유 대기 부정` : 프로세스가 실행되기 전에 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나, 자원이 점유되지 않은 상태에서만 자원 요청을 받도록 합니다.
      - `비선점 부정` : 모든 자원에 대한 선점을 허용합니다.
      - `순환 대기 부정` : 자원을 선형으로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 합니다.
   #### Q) 데드락을 해결하기 위한 방법 중 회복에 대해서 설명해주세요.
   - 데드락을 회복하기 위해서는 먼저 데드락을 탐지하는 과정이 필요합니다. 데드락을 탐지하기 위해 은행원 알고리즘을 사용해야 합니다.
      - `은행원 알고리즘` : 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 안정 상태에 들 수 있는지 여부를 검사하는 것입니다. 
   - 이러한 알고리즘을 통해 데드락을 탐지했다면, 프로세스를 1개 이상을 중단 시키거나, 자원을 선점시키는 방식으로 데드락을 회복할 수 있습니다.
   - 이때, 중단 시키는 작업은 프로세스의 부분 결과가 폐기될 수 있고, 회복하기 위해서는 탐지 알고리즘을 계속 수행해주어야 하기 때문에, busy waiting 문제가 발생할 수 있습니다.

   #### Q) 데드락이 발생하는 4가지 조건 중 왜 3 가지 조건을 만족하면 데드락이 발생하지 않는지에 대해서 설명해주세요.
   - 데드락이 발생하기 위한 4가지 조건 중 하나의 조건을 충족하지 않는 다는 것은 어떠한 한 가지 조건에 대해 예방을 했다고 말 할 수 있습니다. 따라서, 데드락이 발생하지 않습니다.

   > Q) 자바에서 데드락이 발생할 수 있을까요?
   - 멀티 쓰레드 환경으로 동작하게 하고, 동기화 설계를 잘못해준 경우에 데드락이 발생할 수 있습니다.
   - 이를 이해하기 위하여, synchronized에 대해서 이해 할 필요가 있습니다.
   - synchronized 키워드는 동기화가 필요한 메서드나 코드 블럭 앞에 사용하여 동기화 할 수 있습니다. synchronized로 지정된 임계영역은 한 스레드가 이 영역에 접근하여 사용할 때 lock이 걸림으로써 다른 스레드가 접근을 할 수 없게되고, 해당 스레드가 임계영역의 코드를 실행 후 벗어나게 되면 unlock 상태가 되어 그때서야 대기하고 있던 다른 스레드가 이 임계영역에 접근하여 lock을 걸고 사용할 수 있게 됩니다.
   - 데드락이 발생하는 설계 상의 오류는 `synchronized`안에 `synchronized`를 또 선언 할 경우에 발생합니다.
      ```java
      private static void sum(Node n1, Node n2) {
         // 0부터 9까지 반복한다.
         for (int i = 0; i < 10; i++) {
         // n1에 lock을 건다.
            synchronized (n1) {
            // n2에 lock을 건다.
               synchronized (n2) {
               // 값을 가져와서
               int data = n1.getData();
               // i만큼 더한다.
               n1.setData(data + i);
               // 값을 가져와서
               data = n2.getData();
               // i만큼 더한다.
               n2.setData(data + i);
            }
            }
            // 콘솔 출력
            System.out.println(Thread.currentThread().getName() + " i = " + i);
            // 스레드 1초 대기
            sleep();
         }
      }
      ```
   - 다음과 같은 상황에서 쓰레드가 2개가 있을 때 첫 쓰레드에 n1, n2 두번째 쓰레드에 n2, n1을 넣었다고 했을 때, 멀티 쓰레드에서는 병렬 처리를 하기 때문에, n1과 n2가 동시에 락을 획득하는 상황이 생길 수 있습니다.
   - 동시에 n1과 n2에 락이 걸렸을 때, 다음 스탭에서 첫번째 스레드에서 n2에 접근을 하려고 할 때, n2는 락이 걸려있기 때문에 wait상태가 되고, 이어서 두번째 스레드에서도 n1으로 들어가려고 하니 락이 걸려있어 wait 상태로 빠지게 됩니다.
   - 이렇게 두 스레드는 서로의 lock이 풀리는 것을 기다려야 하는 상황이 발생하는 데드락에 빠지게 되는 것입니다.
   - 따라서, 각각의 노드들에 대한 synchronized를 사용하지 않고, 해당 함수의 접근에 있어서 동기화 처리를 하게 되면 데드락 문제가 발생하지 않습니다.
   > Q) synchronized에 대해서 간략하게 설명해주세요.

   ![image](https://tecoble.techcourse.co.kr/static/ff6bf378623f4cbfe190196dcffdc476/1255e/java-monitor.png)
   - 자바의 synchronized 키워드는 스레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다. 즉, 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념입니다.
   - synchronized는 상호 배제를 위해 monitor 기법을 채택하고 있습니다. 여기서 monitor 기법이란, mutex, semaphore 같은 경우에는 직접 lock 변수 혹은 wait, signal을 어떠한 동기화를 위해 직접 명시해야 하는 문제로 인해 개발자가 실수하여 잘못 설계되는 경우가 발생할 수 있습니다. 이를 개선하기 위해 상호 배제를 프로그램으로 구현한 것입니다. 
      ```java
      public static synchronized Instance getInstance() {
         if (Objects.isNull(instance)) {
            instance = new Instance();
         }
         return instance;
      }
      ```
   > Q) 현대 운영체제에서는 데드락 문제를 어떻게 해결하고 있는지 선택해주세요.
   - 힌트 : 예방은 자원 문제가 심해서 회피를 선택합니다.
   - 데드락이 드물게 발생을 하게 되면, 데드락을 해결하기 조치가 더 큰 오버헤드를 발생시킬 수 있습니다. 따라서 이를 방지하기 위해 **데드락 무시 기법**을 채택하고 있으며, 교착상태 발생 시 프로세스를 종료하여 재실행하거나, 자원을 선점하여 회복한다고 합니다.
   - 교착상태를 회피하기 위해서는 계속해서 탐지를 해야하는데, 현대의 OS에서는 데드락이 드물게 발생하기 드물게 발생하기도 하고, 자원을 요청할 때마다 시스템의 상태를 판단하고 알고리즘을 돌려야하기 때문에, 현대 시스템에서는 회피 방법 사용 시에 발생하는 오버헤드를 감당하는 시스템이 없다고 합니다.

   #### Q) 데드락이 발생하는 시나리오
   
   ![Image](https://velog.velcdn.com/images%2Fminseojo%2Fpost%2F5cb6568d-be51-42fa-b860-6f02172fbd02%2Fimage.png)
   
   - 데드락이 발생하는 시나리오 중에서 가장 유명한 시나리오는 식사하는 철학자 입니다. 식사하는 철학자의 진행 방식은 다음과 같습니다.
      1. 일정 시간 생각을 한다.
      2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
      3. 오른쪽 포크가 사용 가능해질 때가지 대기한다. 만약 사용 가능하다면 집어든다.
      4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
      5. 오른쪽 포크를 내려놓는다.
      6. 왼쪽 포크를 내려놓는다.
      7. 다시 1번으로 돌아간다.
   - 이럴 경우 2번을 진행을 하게 되면 모든 철학자들은 포크를 집어들고 있고, 모든 철학자가 오른쪽 포크를 들기 위해 3번 상태에서 머무르는 데드락 상황이 발생합니다.
   
   #### 사진,내용에 대한 출처
   - https://jwprogramming.tistory.com/12
   - https://kadosholy.tistory.com/123
   - https://tecoble.techcourse.co.kr/post/2021-10-23-java-synchronize/
   - https://velog.io/@minseojo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90-%EB%AC%B8%EC%A0%9C
---


### 인터럽트는 언제 발생돼서 어떻게 처리하나요?

---


### 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.

---


### 파일 시스템에 대해 설명해주세요 (FAT,Unix 파일 시스템 )

---


