# 운영체제
### 프로세스,스레드가 무엇인가요?
![Untitled-5](https://user-images.githubusercontent.com/67494004/225917972-cbde23cc-a3ff-46eb-84e3-297ec565378c.png)
* 프로세스를 설명하기 이전에 프로그램의 개념부터 설명하겠습니다. 프로그램은 디스크에 저장된 실행파일 그 자체입니다. 이 프로그램을 더블클릭이나 명령어를 통해 실행하게 되면 메모리에 적재가 되고 이는 프로세스가 됩니다. 프로세스의 실행 단위를 스레드 라고 합니다.

  #### Q) 프로세스의 상태에 대해 설명해주세요.
  - new,ready,running,waiting,terminated 상태가 있습니다. 프로그램이 실행되어 프로세스를 생성중인 상태가 new, CPU에 할당되기를 기다리는 상태 ready, 실행되고 있는 상태 running, 입출력이나 다른 이벤트가 발생하기를 기다리는 상태를 waiting, 프로세스가 종료된 상태를 terminated 입니다.
    #### Q-1) Memory가 부족할 경우, Process는 어떠한 상태로 변하나요?
     - 메모리가 부족하면 프로세스가 "차단됨" 상태로 변경되어 더 많은 메모리를 사용할 수 있을 때까지 기다립니다. 이는 프로세스가 사용 가능한 것보다 더 많은 메모리를 할당하려고 시도하거나 운영 체제가 사용 가능한 리소스를 소비하는 다른 프로세스로 인해 충분한 메모리를 제공할 수 없을 때 발생할 수 있습니다. 프로세스가 충분한 메모리를 확보할 수 있으면 "준비" 상태로 다시 전환하고 실행을 계속할 수 있습니다.
    #### Q-1-1) 꼬리의 꼬리의 꼬리 질문
  #### Q) 프로세스는 다른 프로세스의 정보에 접근할 방법이 없나요? 있다면 방법도 설명해주세요.
    - 기본적으로 각각의 프로세스는 독립된 메모리 공간을 할당받기 때문에 프로세스는 다른 프로세스의 자료에 접근할 수 없습니다. 하지만 다른 프로세스 간에 데이터를 공유하고 상호작용하기 위한 기술을 활용하면 접근할 수 있습니다.
    
  > Q) program → process가 될 때 운영체제가 하는 일
  - 하드웨어 . . ~~
   
---

### 프로세스 메모리 구조에 대해 설명해주세요.

---


### 멀티프로세스, 멀티스레드에 대해 설명해주세요. 
- 멀티프로세스란, 하나의 프로그램을 여러 개의 프로세스로 구성해서, 각 프로세스가 하나의 작업을 수행할 수 있도록 하는 작업입니다.  
- 멀티스레드란, 하나의 프로세스 안에서 두 개 이상의 스레드가 작업을 수행하는 것입니다.

  #### Q) 멀티프로세스와 멀티스레드의 각각의 장단점을 설명해주세요.
  - 멀티프로세스의 장점 : 
     - CPU의 낭비되는 시간을 줄일 수 있습니다. (CPU 사용률을 높일 수 있습니다.)
     - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.
  - 멀티스레드의 장점 : 
     - 운영체제가 시스템 자원을 효율적으로 관리할 수 있습니다.
     - 멀티 프로세스보다 적은 메모리 공간을 가집니다.
     - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 
     - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간 통신의 부담이 줄어듭니다.
  - 공통적인 단점 :
    - context switching 시 오버헤드가 발생합니다.
  - 멀티프로세스의 단점 : 
  - 멀티스레드의 단점 : 
     - 동기화 문제가 발생합니다. (동기화 관리를 잘해주어야 합니다.)
     - 하나의 스레드 장애로 전체 스레드가 종료 될 위험

  #### Q) 싱글스레드와 멀티스레드의 차이를 설명해주세요.
  - 싱글스레드
     - 하나의 프로세스 안에서 하나의 스레드만 사용하는 것입니다.
     - 메인 스레드만으로 작업을 처리합니다. 스레드가 하나라서 작업을 차례대로 처리합니다. 
     - (ex) A,B 작업이 있다고 하면 A작업을 다 처리해야 B작업을 처리할 수 있습니다.
  - 멀티스레드 : 
     - 하나의 프로세스 안에서 두개 이상의 스레드를 사용하는 것입니다. 
     - 메인 스레드 외의 추가적인 스레드를 이용해서 병렬적으로 작업 처리가 가능합니다. 
     - (ex) A,B 작업이 있다고 하면 A->B->A 식으로 처리를 하는 것이 가능합니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088416-530596ec-f817-4629-99e8-23f6228fd30a.png)

  - 추가 조사 : 싱글스레드와 멀티스레드의 장단점
  - 멀티스레드의 장점 
     - (1) 응답성 
        - 프로그램 일부 중단되거나 긴 작업 수행해야 하는 프로그램을 마주하더라도 프로그램 수행이 계속되어 사용자에게 응답 반환이 지속적으로 가능합니다. => 응담성이 좋습니다. 
     - (2) 경제성 
        - 프로세스 내 자원, 메모리 공유하기에 메모리 공간, 자원 소모가 줄어듭니다. 
     - (3) 병렬성 
        - CPU를 여러 개 사용하는 구조에서는 각 스레드가 다른 프로세서에서 병렬적으로 수행될 수 있어, 병렬성이 극대화됩니다. 
  - 멀티스레드의 단점 
     - (1) 시간, 비용
        - context switching, 동기화로 인한 오버헤드 발생 => 싱글코어 멀티스레드는 느립니다.
     - (2) 동기화 문제
        - 공유 자원 동시 접근 경우를 처리해주어야 합니다.

  - 싱글스레드의 장점 
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 동기화 문제 X
        - 동기화 처리 필요가 없습니다. 또한 동기화 처리 비용도 발생하지 않습니다.

  - 싱글스레드의 단점  
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 연산량이 많은 작업 시 비효율 발생
        - 연산이 오래 걸리는 작업이 있으면, 해당 작업 끝낼 때까지 기다려야 다음 작업 할 수 있습니다.
     - (3) 에러 처리를 못하는 경우 멈춥니다.
        - 멀티 스레드는 에러 발생 시 새 스레드를 만들어 이를 처리하지만, 싱글 스레드는 대처하지 못할 수 있습니다.

  #### Q) 멀티스레드와 멀티프로세스가 각각 유리한 경우의 예시를 설명해주세요.
  > 둘의 가장 큰 차이는 메모리 공유 여부입니다. 
  - 다른 메모리 침범을 하지 않아야 하는 병렬적인 경우에는 멀티 프로세스를 이용하는 것이 좋습니다. (ex) 미사일 시스템  
  - 멀티스레드는 사용자 응답성이 중요한 프로그램에 사용하는 것이 좋습니다. (ex) 채팅 프로그램

  #### Q) 스레드에서의 동시성과 병렬성에 대해 설명해주세요.
  - 동시성 : 논리적인 동시성 개념입니다. context switching이 빠르게 일어나면서 프로그램이 동시에 수행되는 것처럼 보이는 것입니다. (실제 동시 실행은 아닙니다.)
     - (ex) 하나의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  - 병렬성 : 물리적 동시성 개념입니다. 실제로 동시에 여러 작업이 수행되는 현상입니다. 
     - (ex) 여러개의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088487-03354b30-f9dd-46ab-b034-b4197b5ffc12.png)

  #### 사진 & 내용 출처 
  - https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread-t5gv4udj
  - https://sas-study.tistory.com/446

---


### PCB와 Context Switching
<img src = "https://user-images.githubusercontent.com/74203371/226113159-6f77bb2d-029a-44fc-b7c4-037874e4cddb.png" width = "300px" height = "500px">

* Process Control Block의 약자인 PCB는 **프로세스의 메타 정보들을 저장해두는 커널에 있는 자료구조** 입니다. PCB에 저장되는 프로세스 메타정보에는 다음과 같이 8개의 메타 정보를 저장합니다.
  1. `Process ID` : PID(Process Identification Number) 주로 PID 라고 줄여서 부릅니다.
  : 프로세스 고유 식별 번호
  2. `Process State`(프로세스 상태)
  : 프로세스의 현재 상태(생성, 준비, 실행, 대기, 종료)를 기억 시킵니다.
  3. `Program Counter`(계수기)
  : 다음에 실행되는 명령어의 주소를 기억시킵니다.
  4. `Process Priority`(스케줄링 정보)
  : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억시킵니다.
  5. `CPU Registers`
  : 프로세스의 레지스터 상태를 저장하는 공간 등, CPU 내 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 등이 갖고 있는 값을 기억시킵니다.
  6. `Owner`(계정 정보)
  : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억시킵니다.
  7. `기억장치 관리 정보`
  : 프로그램이 적재될 기억 장치의 시작 지점(베이스 레지스터), 종료 지점(한계 레지스터), 페이지 테이블 등의 정보를 기억시킵니다.
  8. `입출력 정보`
  : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억시킵니다.

<img src = "https://user-images.githubusercontent.com/74203371/226113194-1107b326-cca0-447f-ac3c-cb85c6e6ac7f.png" width = "1065px" height = "550px">

* Context Switching 이란 **CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB로 부터 읽어 준비 상태 큐에 있던 프로세스를 실행 상태로 옮기는 것** 을 말합니다.   
Context Switching 은 주로 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가 시간(Time Quantum)을 모두 소모(타이머 인터럽트 == 타입아웃 인터럽트 발생) 하거나, I/O 입출력을 위해 대기해야 하는 경우 발생합니다.

  #### Q) Context Switching이 일어날 때, 캐시 관련해서도 프로세스와 스레드의 처리 방법이 다르다고 알고 있습니다. 이를 설명해주세요.
  - 프로세스는 메모리 영역은 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 이 때, 캐시는 참조 지역성의 원리에 의해서 저장이 되는데 참조 지역성의 원리는 시간 지역성과 공간 지역성 두 개로 나뉩니다. 이때, 시간 지역성은 '최근에 접근했던 메모리 공간에 다시 접근하려는 경향' 을 의미하며, 공간 지역성은 '접근한 메모리 공간 근처를 접근하려는 경향' 을 의미합니다.   
**프로세스는 컨텍스트 스위칭이 발생할 때, 독립적인 메모리 영역을 가지고 있기 때문에 메모리 공간 자체가 변경이 일어나게 되는데, 이럴 경우 캐시 메모리의 캐시 히트가 떨어져서 캐시 메모리를 비워줘야 합니다.**
그러나 스레드의 메모리 영역은 프로세스와 동일한 영역으로 구성되어 있지만 code, data, heap 영역을 공유하고, stack 영역만 독립적으로 가지고 있습니다. 따라서, **공유된 데이터들을 사용하여 캐시 히트가 프로세스에 비해 많이 낮아지지 않기 때문에, 캐시 메모리를 비우지 않아도 된다는 장점이 있습니다.**

  #### Q) 프로세스는 여러개의 스레드를 가지고 있는데, 이 스레드들에 대한 정보를 어떻게 가지고 있는가
  - **스레드에 대한 관리는 스레드 제어 블록(TCB)에서 관리를 할 수 있습니다.** 이때, TCB는 시스템에서 생성된 스레드를 나타냅니다. TCB에는 다음과 같은 정보가 저장되어 있습니다.
    1. `Thread ID`
    2. `Thread Status`
    3. `CPU 정보 (PC, Register)`
    4. `Thread Priority`
    5. `스레드의 생성을 트리거한 프로세스를 가리키는 포인터`
    6. `스레드에서 만든 스레드를 가리키는 포인터`
  
    스레드는 커널 영역에서 실행되어야 합니다. 이때 `LWP(Light Weight Process)` 라는 용어가 등장합니다. LWP는 운영 체제에 따라 의미를 다르게 두고 있습니다. 
리눅스의 경우 사용자 레벨 에서의 스레드와 프로세스는 구분이 가능하지만, 스레드가 실행되기 위해서는 커널 영역으로 올라와야하고, 커널 영역에서 cpu해당 스레드를 봤을 때는, 작은 프로세스를 처리한다는     의미로 LWP 를 사용하고 있습니다.   
대부분의 운영체제에서는 사용자 영역 내에서의 스레드는 커널 영역으로 스레드가 이동이 되어서 실행이 되어야 합니다. 이때, 사용자 영역에서 커널 영역으로 스레드를 이동시키는데 이를 도와주는 영역을 LWP     로 사용하고 있습니다. 이때 스레드 간 LWP로 이동되기 위해서 각 스레드끼리 경쟁이 발생하는데, 이를 `PCS(Process-contention scope)` '프로세스 경쟁 범위'라고 하고, LWP로 이동하고 나서도     CPU에 매핑되기 위해서도 스케줄링이 필요합니다. 이러한 것을 `SCS(System Contention Scope)` '시스템 경쟁 범위' 라고 합니다.

    #### Q) 프로세스와 스레드는 Context Switching이 발생할 때 어떤 차이가 있는가
    - 프로세스는 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 따라서 Context Swtiching이 발생할 때, 독립적인 메모리를 포함하여, 캐시 메모리를 비워줘야 해서 스레드에 비해 상대적으로 많은 오버헤드가 발생합니다.
    이와 달리 스레드는 code, data, heap 영역을 공유하고 stack 영역만 독립적으로 가지고 있기 때문에, 캐시 메모리를 비우지 않아도 되고 프로세스에 비해 상대적으로 적은 오버헤드가 발생합니다.
  
  #### Q) Context Switching 에서 프로세스 수행 중에 입출력 상태로 전환되어서 대기 상태로 전환 되는데, CPU를 어떻게 하는 것이 효율적인가?
  - Context Switching 에서 입출력 인터럽트가 발생하게 되면 실행 상태에 있던 프로세스는 대기 상태로 전환됩니다. 이때, CPU 스케줄러에 의해서 해당 프로세스의 자원은 반환됩니다. 이후 CPU가 입출력 인터럽트의 완료를 기다리는 동안 준비 상태 큐에 있는 프로세스 중에서 스케줄링 알고리즘에 따라 실행 상태로 들어가고, 대기 상태에 있던 프로세스는 입출력 작업이 완료되게 되면 다시 준비상태 큐로 들어갑니다.

    #### Q) Context Switching이 인터럽트가 발생할 때만 발생하는가?
    - Context Switching은 다음과 같은 상황에 발생합니다.
      1. 멀티태스킹(Multitasking)
      : 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아가며 수행된다.
      2. 인터럽트 핸들링(Interrupt handling)
      : I/O Request, time slice expired, fork a child, wait for an interrupt
      3. 사용자와 커널 모드 전환(User and kernel mode switching)   
      
      따라서, **모든 상황에서 인터럽트가 발생하므로 인터럽트가 발생할 때에만 발생한다고 할 수 있습니다.** 

      #### Q) 인터럽트는 무조건 들어오는 순서대로 처리를 하는가?
      - 아닙니다. **CPU는 인터럽트를 우선순위에 따라 처리할 수 있습니다.** NMI(Non-Maskable interrupt) 가 발생한 경우 CPU는 해당 인터럽트 부터 처리합니다. 여기서 NMI는 무시될 수 없는 interrupt 입니다. 몇몇 심각한 사건(정전, 하드웨어 고장 등 어찌할 수 없는 오류)등이 해당됩니다.   
많은 컴퓨터에서는 프로그래머블 인터럽트 컨트롤러(PIC : Programmable Interrupt Controller)라는 하드웨어를 사용하여 인터럽트 요청들의 우선순위를 판별합니다.

  
  > Q) 프로세스 컨트롤 블록이 어떤 자료구조로 관리 되는지 알고 있는가
    
  - PCB는 **Doubly Linked List 방식으로 관리**됩니다.
    PCB의 List Head에 PCB들이 생성될 때마다 붙게 됩니다. 주소 값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이합니다.   
    > ~연결 리스트의 구조를 사용함으로써 삽입 `O(1)` 은 용이하다고 생각되지만 (항상 list의 헤드에 붙이기 때문에 위치를 알고 있음.) 삭제에 있어서는 해당 PCB의 위치를 찾고 `O(n)` 연결을 끊는 것 `O(1)` 이기 때문에, 삭제는 용이한지 잘 모르겠습니다..ㅠ 그냥 연결리스트와 배열과 비교를 했을 때 연결 리스트의 탐색은 제외하고 삽입 삭제만 바라봤을 때의 대해서 얘기한거겠죠?~ 동윤님 답변으로 해결되었습니다! `node.prev.next = node.next;`

  > Q) Context Switching 시에 주소공간에 대한 캐시 처리가 어떻게 이루어지는지 설명해주세요.
  
  - TLB를 이해하기 전에 먼저 페이지 테이블을 이해 할 필요가 있습니다.
  기존의 프로세스들을 메모리에 적재할 때, 순차적으로 적재를 하게 되면 단편화 문제가 발생하기 때문에, 이를 방지하기 위해서 가상 메모리 기법이 생겼고, 가상 메모리 기법은 세그멘테이션과 페이징 기법으로 나눌 수 있습니다.   
  가상 메모리 기법으로 분할 된 메모리의 페이지들은 페이지 테이블에서 관리를 하게 되는데, 메모리에 실제 주소를 참조하기 위해서는 
    1. 페이지 테이블에 한번 접근(fetch)
    2. 페이지 테이블을 기반으로 실제 메모리로 접근 (Memory Access)

    와 같은 과정이 필요한데, 실행할 때마다 같은 table에 속한 메모리 주소를 찾고 다시 메인 메모리에 접근해야 하는 불필요한 일이 발생합니다.  
    이런 메모리의 접근을 줄이기 위해서 TLB가 등장했고, TLB는 page table의 임시저장 캐시 역할을 합니다. TLB는 L3 캐시에 위치해있습니다. 이때 TLB에는 최근에 읽었던 변환될 물리 주소를 매핑해서 저장을합니다. 따라서 **TLB를 활용하면 한 프로세스 내의 다른 스레드를 Context Switching 하는 경우 invalid가 발생하지 않아, 주소 공간을 참조하는데 하드웨어 적으로 이점**을 볼 수 있고, **프로세스가 Context Switching을 하게 되는 경우, kernel 주소 공간을 제외한 모든 영역을 invalid 하기 때문에, 스레드와 달리 손해**를 보게 됩니다.
    
    #### 사진 & 내용 출처 
    - https://velog.io/@jaypyon/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9DPCB%EC%9D%B4%EB%9E%80
    - https://afteracademy.com/blog/what-is-context-switching-in-operating-system/
    - https://spurdev.tistory.com/13
    - https://velog.io/@gothae/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-PCB%EC%99%80-Context-Switching
---


### Process Sheduling 알고리즘에는 어떤 것들이 있나요?

---


### CPU Scheduling이 무엇인가요?

