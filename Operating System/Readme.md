# 운영체제
### 프로세스,스레드가 무엇인가요?
![Untitled-5](https://user-images.githubusercontent.com/67494004/225917972-cbde23cc-a3ff-46eb-84e3-297ec565378c.png)
* 프로세스를 설명하기 이전에 프로그램의 개념부터 설명하겠습니다. 프로그램은 디스크에 저장된 실행파일 그 자체입니다. 이 프로그램을 더블클릭이나 명령어를 통해 실행하게 되면 메모리에 적재가 되고 이는 프로세스가 됩니다. 프로세스의 실행 단위를 스레드 라고 합니다.

  #### Q) 프로세스의 상태에 대해 설명해주세요.
  - new,ready,running,waiting,terminated 상태가 있습니다. 프로그램이 실행되어 프로세스를 생성중인 상태가 new, CPU에 할당되기를 기다리는 상태 ready, 실행되고 있는 상태 running, 입출력이나 다른 이벤트가 발생하기를 기다리는 상태를 waiting, 프로세스가 종료된 상태를 terminated 입니다.
    #### Q-1) Memory가 부족할 경우, Process는 어떠한 상태로 변하나요?
     - 메모리가 부족하면 프로세스가 "차단됨" 상태로 변경되어 더 많은 메모리를 사용할 수 있을 때까지 기다립니다. 이는 프로세스가 사용 가능한 것보다 더 많은 메모리를 할당하려고 시도하거나 운영 체제가 사용 가능한 리소스를 소비하는 다른 프로세스로 인해 충분한 메모리를 제공할 수 없을 때 발생할 수 있습니다. 프로세스가 충분한 메모리를 확보할 수 있으면 "준비" 상태로 다시 전환하고 실행을 계속할 수 있습니다.
    #### Q-1-1) 꼬리의 꼬리의 꼬리 질문
  #### Q) 프로세스는 다른 프로세스의 정보에 접근할 방법이 없나요? 있다면 방법도 설명해주세요.
    - 기본적으로 각각의 프로세스는 독립된 메모리 공간을 할당받기 때문에 프로세스는 다른 프로세스의 자료에 접근할 수 없습니다. 하지만 다른 프로세스 간에 데이터를 공유하고 상호작용하기 위한 기술을 활용하면 접근할 수 있습니다.
    
  > Q) program → process가 될 때 운영체제가 하는 일
  - 하드웨어 . . ~~
   
---

### 프로세스 메모리 구조에 대해 설명해주세요.
* 운영체제는 각각의 프로세스에게 메모리를 할당하는데,<br> 위에서부터 스택(Stack), 힙(Heap), 데이터영역(BSS Segment, Data Segment), 코드영역(Code Segment)으로 나눠집니다.

![image](https://user-images.githubusercontent.com/110760593/226155831-d0df44ec-ab99-41d2-b47b-ed67458af7df.png)

- 동적할당은 런타임 단계에서 메모리를 할당받는 것이며 스택과 힙으로 나누어집니다.
- 스택은
  - 위에서 부터 아래로 메모리 주소가 채워집니다.
  - 지역변수, 매개변수, 실행되는 함수 및 반환값이 저장되는 메모리 공간으로, 함수가 호출될 때마다 호출 환경 등 특정 정보가 계속해서 저장됩니다.
  - 컴파일 시에 크기가 결정되는데, 함수가 함수를 호출하는 등에 따라 런타임 시에도 크기가 변경되는 동적인 특징을 가집니다.
  - 참고로 재귀 함수가 호출될 때에는 매 번 새로운 스택 프레임이 사용되기 때문에 함수 내 변수 집합이 다른 함수의 인스턴스 변수를 방해하지 않습니다.
- 힙은
  - 아래에서 위로 메모리 주소가 채워집니다.
  - 동적으로 할당되는 변수들을 저장하며 런타임 시에 크기가 결정됩니다.
  - new(), malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료구조의 경우 Heap 영역을 사용합니다. 
  <br> 예를들어 vector는 내부적으로 Heap 영역을 사용합니다.
  - 힙 메모리는 스택 메모리보다 사용할 수 있는 메모리 공간이 크고 사용이 유연하다는 장점이 있습니다.
  - 그러나 포인터로 메모리에 접근하기 때문에 중간에 한 단계를 더 거쳐 데이터의 Read/Write가 스택에 비해 느립니다.
  
- 정적할당은 컴파일 단계에서 메모리를 할당하는 것이며, 데이터 영역과 코드영역으로 나뉘어서 저장됩니다.
- 데이터 영역은
  - 전역변수, 정적 변수, 배열 등이 저장되는 공간으로 BSS segment 영역과 Data segment 영역으로 나뉩니다.
    - BSS segment는 전역 변수, 정적 변수 중 0으로 초기화 되었거나, 어떤 값으로도 초기화 되지 않은 변수들이 이 곳에 할당됩니다.
    - Data segment는 전역 변수, 정적 변수 중 0이 아닌 값으로 초기화 된 변수가 이 곳에 할당됩니다.
- 코드 영역(Code Segment)은
  - 소스코드(프로그램 명령) 자체를 구성하는 메모리 영역입니다.
  - 프로그램 실행 도중에 작성한 코드가 변경되는 불상사가 생기면 안되기 때문에 읽기만 가능합니다.

  #### Q) 스택이 힙보다 더 빠른 이유는 무엇인가요? (스택에 할당된 변수에 접근하는 것이 힙 할당 변수에 접근하는 것보다 빠른 이유)
  - 스택은 CPU에 의해 관리되며 이미 할당된 공간을 사용하는 것이고, 힙은 OS에 의해 할당해서 사용하는 공간이므로 스택의 속도가 빠릅니다.
   - 컴파일러는 주어진 프로그램을 컴파일하는 과정에서 스택에 할당될 변수들의 정확한 크기와 할당 순서를 알 수 있어,
   <br> 스택 기준 상대위치(offset)를 정확하게 알 수 있습니다.
   <br> 따라서 스택에 할당된 변수들은 add(스택바닥 + offset) 이후 load만으로 변수의 값을 읽어들일 수 있습니다.
   - 힙은 OS에 의해 관리되어, 어셈블리를 컴파일하는 단계에서는 이 변수가 힙의 어떤 offset에 할당될지 알 수 없습니다.
    <br> 따라서 OS에서 할당받은 주소를 스택에 할당된 변수에 저장해두고,
    <br> 실제로 힙에 접근할 때는 add -> load로 변수의 주소값을 읽어들인 뒤 다시 그 주소를 load해야 합니다.
    <br> 즉 포인터로 메모리에 접근하기 때문에 중간에 한 단계를 더 거쳐 데이터의 Read/Write가 스택에 비해 느립니다.
  
  #### Q) 프로세스의 메모리 구조를 나누는 이유는 무엇인가요?
  - 한 프로그램이 실행될 때 각각의 변수, 함수, 클래스 등이 호출되고 해제되는 시기는 전부 다르기 때문에, 
  <br> 각각의 특성에 따라 메모리를 효율적으로 사용하기 위해서 메모리 구조를 나누는 것입니다.
  - 예를 들어 함수 내에서 한 번 사용되는 지역 변수가 프로그램 끝까지 메모리에 남아있게 되면 메모리가 낭비됩니다.

  #### Q) 운영체제도 프로세스 주소공간을 가지나요?
  - 메모리에 상주하는 운영체제 부분을 커널이라고 하는데, 커널도 프로세스와 유사하게 코드, 데이터, 스택으로 구성된 주소공간을 가집니다.
  - 단 프로세스 주소 공간보다 더 강력한 보안성을 가진다는 특성이 있습니다.
  
  #### Q) 정적변수와 전역변수의 차이는 무엇인가요?
  - 전역변수와 정적변수는 생명 주기는 동일하지만 두 변수가 접근할 수 있는 범위(scope)에서 차이가 존재합니다.
  <br> 전역변수는 해당 프로그램(실행 파일)의 어떤 파일과 함수에도 접근이 가능하지만 
  <br> 정적 변수는 해당 변수가 선언된 파일이나 함수 내에서만 접근이 가능합니다.

  #### Q) 스레드는 프로세스의 어떤 부분을 공유하고 공유하지 않나요?
  - 스레드는 프로세스 내의 스택 메모리 영역을 제외한 다른 메모리 영역 (code / data / heap)은 다른 스레드와 공유합니다. 

  #### Q) 스택을 따로 할당하는 이유는 무엇인가요?
  - 스택은 함수 호출 시 전달되는 인자, 복귀할 주소 값, 함수 내 선언하는 변수 등을 저장하는 메모리 공간입니다. 
  <br> 각각의 스레드가 독립적인 함수 호출이 가능하려면 스택 공간이 독립적이어야 합니다.
  <br> 따라서 스레드가 독립적인 실행 흐름을 가질 수 있도록 독립된 스택을 할당하는 것입니다.
  
  #### Q) 초기화하지 않은 변수들은 어디에 저장되나요? 그리고 두 영역을 구분하는 이유는 무엇인가요?
  - 전역 변수, 정적 변수 중 0으로 초기화 되었거나 어떠한 값으로도 초기화 되어 있지 않은 변수들은 BSS segment 영역에 할당됩니다.
  - 전역 변수, 정적 변수 중 0이 아닌 값으로 초기화 된 변수 Data segment 메모리 영역에 할당됩니다.
  - 초기화 되지 않은 변수들은 프로그램이 실행될 때 해당 영역만 잡아주고 그 값을 저장할 필요가 없지만, 초기화 된 값은 그 값을 저장하고 있어야 합니다. 
  <br> 따라서 BSS segment의 변수들이 많아져도 프로그램이 실행 코드 사이즈 영역을 늘리지 않아도 되므로 효율성 측면에서 따로 구분해서 저장합니다.
  
  #### Q) CPU가 명령을 확인하고 코드를 실행할 때 어떤 일들이 일어나나요?
  - CPU는 메모리에서 명령어를 계속 가져와서 수행합니다. 이 때 프로그램 카운터에 CPU가 다음으로 실행할 명령어의 주소가 들어있습니다.
  - CPU가 해당 주소에서 명령어를 가져 온 뒤, 프로그램 카운터를 증가시켜 그 다음 실행할 명령어 주소를 대입합니다.
  - 가저온 명령을 실행한 뒤 다시 위 과정을 반복합니다.

  #### Q) 스레드 주소 공간은 어떻게 구성되어 있을까요?
  - 스레드 주소 공간은 스레드 사적공간과 스레드들 간 공유공간으로 나누어집니다.
  - 스레드 사적 공간은 다시 스레드 코드, 스레드 로컬 스토리지, 스레드 사용자 스택과 스레드 커널 스택으로 구성되고
  <br> 스레드 공유 공간은 프로세스에 선언된 코드, 데이터, 힙 공간으로 구성됩니다.
    - 스레드 코드 영역 : 스레드가 실행할 작업이 들어있습니다. 프로세스 코드 영역에 있는 다른 모든 함수를 호출 할 수 있습니다.
    - 스레드 데이터 영역 : 개별 스레드 전용 공간엔 스레드 로컬 스토리지와 프로세스에 의해 공유되는 변수 공간이 있습니다.
    - 스레드 힙 : 모든 스레드가 동적 할당을 받는 공간으로 프로세스 힙 공간을 사용합니다.
    - 스레드 스택 :  프로세스 스택의 일부분을 할당합니다.
    #### Q-1) 스레드 제어 블록은 어디에 저장되나요?
    - 스레드의 실행 상태 정보는 스레드 컨텍스트라고 하며 이는 CPU 레지스터 값으로 스레드 제어블록(TCB)에 저장되어 있습니다.
    - TCB는 커널 영역에 만들어지고, 커널에 의해서 관리됩니다.
  
  #### Q) 리눅스 개발자는 스레드와 프로세스를 구분짓지 않는데 그 이유는 무엇인가요?
  - 프로세스가 스레드를 만드는 과정은, 프로세스가 자식 프로세스를 만드는 과정과 시스템 내에선 크게 다르지 않습니다.
  <br> 스레드 또한 부모 프로세스 PCB 정보를 모두 가집니다. 하지만 PCB 내 대부분의 정보가 포인터로 이루어져 있고,
  <br> 몇몇 구조체에서만 스레드임을 알기 위한 다른 정보가 들어 있습니다.
  <br>즉 스레드는 부모 프로세스 정보를 포인터로 갖고 있어 같은 정보에 접근할 수 있지만 굉장히 가볍고, 해당 정보로 필요한 작업만을 처리할 수 있습니다.
  <br> 따라서 쓰레드를 세미 프로세스 또는 가벼운 프로세스(Light-weight process)라고 합니다.
  <br> 참고로 리눅스에서는 스레드를 생성하면 PID는 부모 프로세스와 같지만 스레드로서 고유 SPID를 갖습니다. (ps -T)

---


### 멀티프로세스, 멀티스레드에 대해 설명해주세요. 
- 멀티프로세스란, 하나의 프로그램을 여러 개의 프로세스로 구성해서, 각 프로세스가 하나의 작업을 수행할 수 있도록 하는 작업입니다.  
- 멀티스레드란, 하나의 프로세스 안에서 두 개 이상의 스레드가 작업을 수행하는 것입니다.

  #### Q) 멀티프로세스와 멀티스레드의 각각의 장단점을 설명해주세요.
  - 멀티프로세스의 장점 : 
     - CPU의 낭비되는 시간을 줄일 수 있습니다. (CPU 사용률을 높일 수 있습니다.)
     - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.
  - 멀티스레드의 장점 : 
     - 운영체제가 시스템 자원을 효율적으로 관리할 수 있습니다.
     - 멀티 프로세스보다 적은 메모리 공간을 가집니다.
     - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 
     - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간 통신의 부담이 줄어듭니다.
  - 공통적인 단점 :
    - context switching 시 오버헤드가 발생합니다.
  - 멀티프로세스의 단점 : 
  - 멀티스레드의 단점 : 
     - 동기화 문제가 발생합니다. (동기화 관리를 잘해주어야 합니다.)
     - 하나의 스레드 장애로 전체 스레드가 종료 될 위험

  #### Q) 싱글스레드와 멀티스레드의 차이를 설명해주세요.
  - 싱글스레드
     - 하나의 프로세스 안에서 하나의 스레드만 사용하는 것입니다.
     - 메인 스레드만으로 작업을 처리합니다. 스레드가 하나라서 작업을 차례대로 처리합니다. 
     - (ex) A,B 작업이 있다고 하면 A작업을 다 처리해야 B작업을 처리할 수 있습니다.
  - 멀티스레드 : 
     - 하나의 프로세스 안에서 두개 이상의 스레드를 사용하는 것입니다. 
     - 메인 스레드 외의 추가적인 스레드를 이용해서 병렬적으로 작업 처리가 가능합니다. 
     - (ex) A,B 작업이 있다고 하면 A->B->A 식으로 처리를 하는 것이 가능합니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088416-530596ec-f817-4629-99e8-23f6228fd30a.png)

  - 추가 조사 : 싱글스레드와 멀티스레드의 장단점
  - 멀티스레드의 장점 
     - (1) 응답성 
        - 프로그램 일부 중단되거나 긴 작업 수행해야 하는 프로그램을 마주하더라도 프로그램 수행이 계속되어 사용자에게 응답 반환이 지속적으로 가능합니다. => 응담성이 좋습니다. 
     - (2) 경제성 
        - 프로세스 내 자원, 메모리 공유하기에 메모리 공간, 자원 소모가 줄어듭니다. 
     - (3) 병렬성 
        - CPU를 여러 개 사용하는 구조에서는 각 스레드가 다른 프로세서에서 병렬적으로 수행될 수 있어, 병렬성이 극대화됩니다. 
  - 멀티스레드의 단점 
     - (1) 시간, 비용
        - context switching, 동기화로 인한 오버헤드 발생 => 싱글코어 멀티스레드는 느립니다.
     - (2) 동기화 문제
        - 공유 자원 동시 접근 경우를 처리해주어야 합니다.

  - 싱글스레드의 장점 
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 동기화 문제 X
        - 동기화 처리 필요가 없습니다. 또한 동기화 처리 비용도 발생하지 않습니다.

  - 싱글스레드의 단점  
     - (1) 비용, 시간
        - context switching로 인한 오버헤드 발생하지 않습니다.
     - (2) 연산량이 많은 작업 시 비효율 발생
        - 연산이 오래 걸리는 작업이 있으면, 해당 작업 끝낼 때까지 기다려야 다음 작업 할 수 있습니다.
     - (3) 에러 처리를 못하는 경우 멈춥니다.
        - 멀티 스레드는 에러 발생 시 새 스레드를 만들어 이를 처리하지만, 싱글 스레드는 대처하지 못할 수 있습니다.

  #### Q) 멀티스레드와 멀티프로세스가 각각 유리한 경우의 예시를 설명해주세요.
  > 둘의 가장 큰 차이는 메모리 공유 여부입니다. 
  - 다른 메모리 침범을 하지 않아야 하는 병렬적인 경우에는 멀티 프로세스를 이용하는 것이 좋습니다. (ex) 미사일 시스템  
  - 멀티스레드는 사용자 응답성이 중요한 프로그램에 사용하는 것이 좋습니다. (ex) 채팅 프로그램

  #### Q) 스레드에서의 동시성과 병렬성에 대해 설명해주세요.
  - 동시성 : 논리적인 동시성 개념입니다. context switching이 빠르게 일어나면서 프로그램이 동시에 수행되는 것처럼 보이는 것입니다. (실제 동시 실행은 아닙니다.)
     - (ex) 하나의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  - 병렬성 : 물리적 동시성 개념입니다. 실제로 동시에 여러 작업이 수행되는 현상입니다. 
     - (ex) 여러개의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
  ![image](https://user-images.githubusercontent.com/76711238/226088487-03354b30-f9dd-46ab-b034-b4197b5ffc12.png)

  #### 사진 & 내용 출처 
  - https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread-t5gv4udj
  - https://sas-study.tistory.com/446

---


### PCB와 Context Switching
<img src = "https://user-images.githubusercontent.com/74203371/226113159-6f77bb2d-029a-44fc-b7c4-037874e4cddb.png" width = "300px" height = "500px">

* Process Control Block의 약자인 PCB는 **프로세스의 메타 정보들을 저장해두는 커널에 있는 자료구조** 입니다. PCB에 저장되는 프로세스 메타정보에는 다음과 같이 8개의 메타 정보를 저장합니다.
  1. `Process ID` : PID(Process Identification Number) 주로 PID 라고 줄여서 부릅니다.
  : 프로세스 고유 식별 번호
  2. `Process State`(프로세스 상태)
  : 프로세스의 현재 상태(생성, 준비, 실행, 대기, 종료)를 기억 시킵니다.
  3. `Program Counter`(계수기)
  : 다음에 실행되는 명령어의 주소를 기억시킵니다.
  4. `Process Priority`(스케줄링 정보)
  : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억시킵니다.
  5. `CPU Registers`
  : 프로세스의 레지스터 상태를 저장하는 공간 등, CPU 내 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 등이 갖고 있는 값을 기억시킵니다.
  6. `Owner`(계정 정보)
  : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억시킵니다.
  7. `기억장치 관리 정보`
  : 프로그램이 적재될 기억 장치의 시작 지점(베이스 레지스터), 종료 지점(한계 레지스터), 페이지 테이블 등의 정보를 기억시킵니다.
  8. `입출력 정보`
  : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억시킵니다.

<img src = "https://user-images.githubusercontent.com/74203371/226113194-1107b326-cca0-447f-ac3c-cb85c6e6ac7f.png" width = "1065px" height = "550px">

* Context Switching 이란 **CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB로 부터 읽어 준비 상태 큐에 있던 프로세스를 실행 상태로 옮기는 것** 을 말합니다.   
Context Switching 은 주로 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가 시간(Time Quantum)을 모두 소모(타이머 인터럽트 == 타입아웃 인터럽트 발생) 하거나, I/O 입출력을 위해 대기해야 하는 경우 발생합니다.

  #### Q) Context Switching이 일어날 때, 캐시 관련해서도 프로세스와 스레드의 처리 방법이 다르다고 알고 있습니다. 이를 설명해주세요.
  - 프로세스는 메모리 영역은 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 이 때, 캐시는 참조 지역성의 원리에 의해서 저장이 되는데 참조 지역성의 원리는 시간 지역성과 공간 지역성 두 개로 나뉩니다. 이때, 시간 지역성은 '최근에 접근했던 메모리 공간에 다시 접근하려는 경향' 을 의미하며, 공간 지역성은 '접근한 메모리 공간 근처를 접근하려는 경향' 을 의미합니다.   
**프로세스는 컨텍스트 스위칭이 발생할 때, 독립적인 메모리 영역을 가지고 있기 때문에 메모리 공간 자체가 변경이 일어나게 되는데, 이럴 경우 캐시 메모리의 캐시 히트가 떨어져서 캐시 메모리를 비워줘야 합니다.**
그러나 스레드의 메모리 영역은 프로세스와 동일한 영역으로 구성되어 있지만 code, data, heap 영역을 공유하고, stack 영역만 독립적으로 가지고 있습니다. 따라서, **공유된 데이터들을 사용하여 캐시 히트가 프로세스에 비해 많이 낮아지지 않기 때문에, 캐시 메모리를 비우지 않아도 된다는 장점이 있습니다.**

  #### Q) 프로세스는 여러개의 스레드를 가지고 있는데, 이 스레드들에 대한 정보를 어떻게 가지고 있는가
  - **스레드에 대한 관리는 스레드 제어 블록(TCB)에서 관리를 할 수 있습니다.** 이때, TCB는 시스템에서 생성된 스레드를 나타냅니다. TCB에는 다음과 같은 정보가 저장되어 있습니다.
    1. `Thread ID`
    2. `Thread Status`
    3. `CPU 정보 (PC, Register)`
    4. `Thread Priority`
    5. `스레드의 생성을 트리거한 프로세스를 가리키는 포인터`
    6. `스레드에서 만든 스레드를 가리키는 포인터`
  
    스레드는 커널 영역에서 실행되어야 합니다. 이때 `LWP(Light Weight Process)` 라는 용어가 등장합니다. LWP는 운영 체제에 따라 의미를 다르게 두고 있습니다. 
리눅스의 경우 사용자 레벨 에서의 스레드와 프로세스는 구분이 가능하지만, 스레드가 실행되기 위해서는 커널 영역으로 올라와야하고, 커널 영역에서 cpu해당 스레드를 봤을 때는, 작은 프로세스를 처리한다는     의미로 LWP 를 사용하고 있습니다.   
대부분의 운영체제에서는 사용자 영역 내에서의 스레드는 커널 영역으로 스레드가 이동이 되어서 실행이 되어야 합니다. 이때, 사용자 영역에서 커널 영역으로 스레드를 이동시키는데 이를 도와주는 영역을 LWP     로 사용하고 있습니다. 이때 스레드 간 LWP로 이동되기 위해서 각 스레드끼리 경쟁이 발생하는데, 이를 `PCS(Process-contention scope)` '프로세스 경쟁 범위'라고 하고, LWP로 이동하고 나서도     CPU에 매핑되기 위해서도 스케줄링이 필요합니다. 이러한 것을 `SCS(System Contention Scope)` '시스템 경쟁 범위' 라고 합니다.

    #### Q) 프로세스와 스레드는 Context Switching이 발생할 때 어떤 차이가 있는가
    - 프로세스는 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 따라서 Context Swtiching이 발생할 때, 독립적인 메모리를 포함하여, 캐시 메모리를 비워줘야 해서 스레드에 비해 상대적으로 많은 오버헤드가 발생합니다.
    이와 달리 스레드는 code, data, heap 영역을 공유하고 stack 영역만 독립적으로 가지고 있기 때문에, 캐시 메모리를 비우지 않아도 되고 프로세스에 비해 상대적으로 적은 오버헤드가 발생합니다.
  
  #### Q) Context Switching 에서 프로세스 수행 중에 입출력 상태로 전환되어서 대기 상태로 전환 되는데, CPU를 어떻게 하는 것이 효율적인가?
  - Context Switching 에서 입출력 인터럽트가 발생하게 되면 실행 상태에 있던 프로세스는 대기 상태로 전환됩니다. 이때, CPU 스케줄러에 의해서 해당 프로세스의 자원은 반환됩니다. 이후 CPU가 입출력 인터럽트의 완료를 기다리는 동안 준비 상태 큐에 있는 프로세스 중에서 스케줄링 알고리즘에 따라 실행 상태로 들어가고, 대기 상태에 있던 프로세스는 입출력 작업이 완료되게 되면 다시 준비상태 큐로 들어갑니다.

    #### Q) Context Switching이 인터럽트가 발생할 때만 발생하는가?
    - Context Switching은 다음과 같은 상황에 발생합니다.
      1. 멀티태스킹(Multitasking)
      : 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아가며 수행된다.
      2. 인터럽트 핸들링(Interrupt handling)
      : I/O Request, time slice expired, fork a child, wait for an interrupt
      3. 사용자와 커널 모드 전환(User and kernel mode switching)   
      
      따라서, **모든 상황에서 인터럽트가 발생하므로 인터럽트가 발생할 때에만 발생한다고 할 수 있습니다.** 

      #### Q) 인터럽트는 무조건 들어오는 순서대로 처리를 하는가?
      - 아닙니다. **CPU는 인터럽트를 우선순위에 따라 처리할 수 있습니다.** NMI(Non-Maskable interrupt) 가 발생한 경우 CPU는 해당 인터럽트 부터 처리합니다. 여기서 NMI는 무시될 수 없는 interrupt 입니다. 몇몇 심각한 사건(정전, 하드웨어 고장 등 어찌할 수 없는 오류)등이 해당됩니다.   
많은 컴퓨터에서는 프로그래머블 인터럽트 컨트롤러(PIC : Programmable Interrupt Controller)라는 하드웨어를 사용하여 인터럽트 요청들의 우선순위를 판별합니다.

  
  > Q) 프로세스 컨트롤 블록이 어떤 자료구조로 관리 되는지 알고 있는가
    
  - PCB는 **Doubly Linked List 방식으로 관리**됩니다.
    PCB의 List Head에 PCB들이 생성될 때마다 붙게 됩니다. 주소 값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이합니다.   
    > ~연결 리스트의 구조를 사용함으로써 삽입 `O(1)` 은 용이하다고 생각되지만 (항상 list의 헤드에 붙이기 때문에 위치를 알고 있음.) 삭제에 있어서는 해당 PCB의 위치를 찾고 `O(n)` 연결을 끊는 것 `O(1)` 이기 때문에, 삭제는 용이한지 잘 모르겠습니다..ㅠ 그냥 연결리스트와 배열과 비교를 했을 때 연결 리스트의 탐색은 제외하고 삽입 삭제만 바라봤을 때의 대해서 얘기한거겠죠?~ 동윤님 답변으로 해결되었습니다! `node.prev.next = node.next;`

  > Q) Context Switching 시에 주소공간에 대한 캐시 처리가 어떻게 이루어지는지 설명해주세요.
  
  - TLB를 이해하기 전에 먼저 페이지 테이블을 이해 할 필요가 있습니다.
  기존의 프로세스들을 메모리에 적재할 때, 순차적으로 적재를 하게 되면 단편화 문제가 발생하기 때문에, 이를 방지하기 위해서 가상 메모리 기법이 생겼고, 가상 메모리 기법은 세그멘테이션과 페이징 기법으로 나눌 수 있습니다.   
  가상 메모리 기법으로 분할 된 메모리의 페이지들은 페이지 테이블에서 관리를 하게 되는데, 메모리에 실제 주소를 참조하기 위해서는 
    1. 페이지 테이블에 한번 접근(fetch)
    2. 페이지 테이블을 기반으로 실제 메모리로 접근 (Memory Access)

    와 같은 과정이 필요한데, 실행할 때마다 같은 table에 속한 메모리 주소를 찾고 다시 메인 메모리에 접근해야 하는 불필요한 일이 발생합니다.  
    이런 메모리의 접근을 줄이기 위해서 TLB가 등장했고, TLB는 page table의 임시저장 캐시 역할을 합니다. TLB는 L3 캐시에 위치해있습니다. 이때 TLB에는 최근에 읽었던 변환될 물리 주소를 매핑해서 저장을합니다. 따라서 **TLB를 활용하면 한 프로세스 내의 다른 스레드를 Context Switching 하는 경우 invalid가 발생하지 않아, 주소 공간을 참조하는데 하드웨어 적으로 이점**을 볼 수 있고, **프로세스가 Context Switching을 하게 되는 경우, kernel 주소 공간을 제외한 모든 영역을 invalid 하기 때문에, 스레드와 달리 손해**를 보게 됩니다.
    
    #### 사진 & 내용 출처 
    - https://velog.io/@jaypyon/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9DPCB%EC%9D%B4%EB%9E%80
    - https://afteracademy.com/blog/what-is-context-switching-in-operating-system/
    - https://spurdev.tistory.com/13
    - https://velog.io/@gothae/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-PCB%EC%99%80-Context-Switching
---


### Process Sheduling 알고리즘에는 어떤 것들이 있나요?

---


### CPU Scheduling이 무엇인가요?

