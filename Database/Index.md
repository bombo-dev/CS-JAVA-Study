# Index를 사용하는데 쓰이는 자료구조는 무엇인지 설명해주세요.
- DB의 인덱스는 데이터베이스에서 데이터 검색 속도를 향상시키기 위해 사용되는 데이터 구조입니다.  
- 일반적으로 데이터베이스에서는 테이블에 대한 하나 이상의 인덱스를 생성할 수 있습니다. - 인덱스를 생성하면 데이터베이스는 해당 열(또는 열의 조합)을 정렬하여 검색 시에 더 효율적으로 데이터를 찾을 수 있습니다. 
- 인덱스는 테이블의 기본 키(primary key) 또는 고유한 값이 자주 사용되는 열에 생성하는 것이 일반적입니다.
- 인덱스를 사용하면 데이터베이스는 테이블을 순차적으로 검색하는 대신 인덱스를 사용하여 레코드를 직접 찾을 수 있습니다. 
- 이는 검색 속도를 크게 향상시키며, 특히 대량의 데이터가 있는 경우에 유용합니다. 
- 그러나 인덱스를 생성하면 데이터베이스의 저장 공간을 소비하고 데이터 수정 작업(삽입, 수정, 삭제)에 약간의 오버헤드가 발생할 수 있습니다. 
- 따라서 인덱스를 생성할 때에는 성능 향상과 저장 공간 및 오버헤드 사이의 균형을 고려해야 합니다.
- DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능입니다. 

### Q) Index를 사용하는데 쓰이는 자료구조는 무엇인지 설명해주세요.
  - 일반적으로 B-트리나 B+트리가 인덱스를 구현하는데 주로 사용되는 자료구조입니다. 
  - B-트리는 데이터베이스 시스템에서 널리 사용되는 자료구조로, 순서를 유지하면서 데이터를 저장하고 검색할 수 있도록 합니다. B+트리는 B-트리의 변형으로, 인덱스를 더 효율적으로 관리하고 범위 검색에 특화되어 있습니다.

    - ### Q-1) B-tree vs B+tree

      - 1. B-트리
          - 데이터베이스 시스템에서 사용되는 자료구조로, 순서를 유지하면서 데이터를 저장하고 검색할 수 있도록 합니다. B-트리는 일반적으로 균형 잡힌 트리로 구현되며, 각 노드는 여러 개의 키와 포인터를 가질 수 있습니다. B-트리의 특징은 다음과 같습니다:
          - 각 노드는 여러 개의 키를 가질 수 있으며, 키는 정렬된 상태를 유지합니다.
          - 모든 리프 노드는 동일한 레벨에 위치하며, 실제 데이터와 연결된다.
          - 노드 내의 키의 개수는 일정 범위 내에서 유지되며, 이를 통해 트리의 균형을 유지합니다.
          - 키를 통해 데이터에 빠르게 액세스할 수 있으며, 범위 검색도 지원합니다.

      - 2. B+트리
          - B-트리의 변형으로, 인덱스를 더 효율적으로 관리하고 범위 검색에 특화되어 있습니다.  
          - B+트리는 내부 노드에는 키만 저장하고, 실제 데이터는 리프 노드에만 저장합니다. 이로 인해 리프 노드가 연결 리스트로 구성되어 데이터에 대한 순차 접근이 용이해집니다.
          - B+트리는 범위 검색을 위해 리프 노드들을 연결 리스트로 연결합니다. 따라서 범위 검색에 대한 성능이 향상됩니다.
          - B+트리는 더 많은 키를 갖는 구조를 가질 수 있으므로, 메모리 공간을 더 효율적으로 사용할 수 있습니다.

|          특징         |      B-트리          |       B+트리              |
|-----------------------|----------------------|-----------------------|
|    키 저장           | 내부 노드 및 리프 노드 | 내부 노드: 키만 저장  |
|                            |                           | 리프 노드: 데이터와 키 저장 |
|    리프 노드 구성  | 데이터와 키 모두 저장 | 데이터만 저장(연결 리스트 형태)|
|    범위 검색           | 지원                     | 특화되어 지원            |
|    키의 개수          | 일정 범위 내에서 유지   | 더 많은 키를 갖는 구조  |
|    메모리 공간 사용| 상대적으로 많은 공간 사용 | 효율적으로 사용        |
|    성능                  | 일반적인 검색 및 정렬에 유리 | 범위 검색에 유리      |


    
    
  > ### Q-2) 사용하시는 RDBMS 는 B+tree 의 리프노드 구현할 때 Linked List, Circular Double Linked List 중에 어떤 것을 채택하시는 지 아시나요?

  - PostgreSQL : 
      - PostgreSQL은 리프 노드를 원형 이중 연결 리스트(Circular Double Linked List)로 구성하여 데이터에 대한 순차 접근을 지원하고, 빠른 범위 검색을 가능하게 합니다.

  - MySQL : 
      - MySQL은 B-tree의 리프 노드 구현에 "Linked List"를 채택하고 있습니다.

  - (+) **Linked List vs Circular Double Linked List**
      - Circular Double Linked List 는 하나의 노드에서 모든 노드로의 접근이 가능하다는 장점을 가지고 있습니다. 
      - 링크를 따라가다가 보면 모든 노드에 접근한 후, 다시 처음으로 돌아오게 되는 것입니다. 
      - 이렇게 되면 노드의 삽입과 삭제 연산이 기존 단순 연결 리스트보다 더욱 단순해지게 됩니다. (삽입과 삭제 연산 자체는 단순 연결 리스트와 거의 같으나, 연결 리스트의 처음과 끝에 삽입하는 것이 쉬워집니다)


### Q) 왜 검색이 O(1)인 해시 자료구조가 아닌, B-tree를 사용하나요? 
  - 데이터에 접근하는 시간복잡도가 거의 O(1)인 HashTable 더 효율적일 것이라고 생각하겠지만, SELECT Query의 조건에는 부등호(< >)연산도 포함이 됩니다. HashTable을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생합니다. 동등 연산(=)에 특화된 HashTable은 데이터베이스 자료구조로 적합하지 않습니다.

### Q) Index를 적용하면 좋은 곳에 대해 설명해주세요.
  - 1) 카디널리티가 높은 곳 (중복도가 낮고 데이터가 분산돼있는 상태)
    - 중복도가 낮으면 cardinality가 높다고 표현
    - 중복도가 높으면 cardinality가 낮다고 표현

  - 2) 수정, 삭제가 잘 일어나지 않는 곳 
    - 인덱스 테이블은 "이진트리 검색"을 사용하기 때문에 기본적으로 정렬되어 있는 상태입니다. 
    - 그래서 만약 인덱스 테이블이 참조하는 테이블에서 "삽입", "삭제", "수정"이 자주 일어나게 된다면, 인덱스 테이블에서는 **데이터를 재정렬**하면서 삽입, 삭제, 수정이 이루어지기 때문에 전체적인 성능 저하를 초래할 수 있습니다.
    - 인덱스는 수정 시, 기존 것을 수정하는 게아니라 기존 인덱스를 지우고 새로 인덱스를 생성한다고 합니다. 이는 시간이 오래 소요될 것입니다. 
    
  - 3) WHERE 조건 절에 자주 사용되는 컬럼, 분포도가 높은 컬럼


**인덱스 설정 기준**
- 카디널리티 (Cardinality) : 높을 수록 적합
   - 한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋습니다.
- 선택도 (Selectivity) : 낮을 수록 적합 (5~10% 적정)
   - 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지
- 활용도 : 높을 수록 적합
   - 해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값
- 중복도 : 없을 수록 적합

- (+) interesting : 배달의 민족 vs 페이스북 
  - "배달의 민족"과 같은 서비스는 주로 사용자가 지역별 배달 음식점을 조회하고 검색하는 기능이 서비스의 주요 기능이기 때문에 인덱스 기능을 잘 사용한다면, 데이터 베이스의 성능을 최적화시킬 수 있을 것입니다. 
  - 반면에 "페이스북"과 같은 소셜미디어는 새로운 게시글들이 사용자들에 의해 끊임없이 생성되기 때문에 (삽입, 수정 자주 일어남) 인덱스 기능을 사용하는 것이 오히려 성능 저하에 원인이 될 수 있습니다.

- ### Q-1) User의 성별 (남/여)에 인덱스를 거는 것에 대해 효과가 어떻게 나올까요? 
   - 중복도가 높은 칼럼이기에 (카디널리티가 낮습니다) 효과가 좋지 않습니다.

- ### Q-2) Index에서 null 값을 허용하나요?
   - DB 마다 다릅니다.
   - 오라클 :  NULL 값에 대해 인덱스를 생성하지 않기 때문에 NULL 값이 허용된 컬럼은 distinct 시 인덱스를 사용할 수 없습니다. (NULL이 있는지 없는지 FULL SCAN을 해야만 알 수 있으므로)
   - MySQL : MyISAM, InnoDB, BDB, MEMORY 엔진을 사용할 경우, NULL도 INDEX를 탑니다.
   
   - 데이터베이스 시스템에서 인덱스를 걸때 NULL를 제외해주고 인덱스를 생성할 수 있는 기능을 제공합니다. 
      - 인덱스를 걸때 NULL를 제외해주고 인덱스를 생성할 수 있는 기능을 제공하지 않는다면?
         - NULL도 인덱스가 되버려 저장 공간이 심각하게 낭비 될 것입니다.
   - null 도 index 가 되기 때문에 굳이 null 에 index를 걸지 않아도 됨 

   

### Q) Index가 추가 삭제 혹은 수정이 된다면 어떻게 될까요?  
  - INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생합니다. 
  - 1. INSERT
    - INSERT 의 경우 INDEX 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따릅니다. 

  - 2.  DELETE
    - 인덱스에서 데이터는 지워지지 않으며, '사용하지 않는다'는 의미를 표시만 해둡니다 (flag). 일반적인 테이블은 데이터가 DELETE 되면 해당 위치 데이터가 지워지고 사용이 가능하지만 인덱스는 그렇지 않습니다.
    - INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됩니다. 즉 row 의 수는 그대로인 것이죠.
    - 실제 데이터는 10 만건인데 데이터가 100 만건 있는 결과를 낳을 수도 있는 것입니다.     
    - 이렇게 되면 인덱스는 더 이상 제 역할을 못하게 되는 것입니다. 

  - 3. UPDATE
    - UPDATE 의 경우는 INSERT 의 경우, DELETE 의 경우의 문제점을 동시에 수반합니다.     
    - 인덱스에선 UPDATE 작업이 없습니다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문입니다. 
    - 즉 변경 전 데이터는 삭제되지 않고 insert 로 인한 split 도 발생하게 됩니다

### Q) Index를 사용하지 않으면 생기는 문제점은 무엇이 있을까요?
- 항상 테이블 풀 스캔을 진행해야 합니다.  

### Q) 항상 인덱스를 쓰면 성능이 좋아질까요?
- 아닙니다.
- 1. 인덱스 유지 비용: 
   인덱스는 데이터베이스에서 추가적인 공간을 차지하며 (보통 인덱스 하나당 데이터 저장 크기의 5~20% 가량의 저장공간을 사용), 데이터의 삽입, 업데이트, 삭제 작업 시에도 인덱스를 유지해야 합니다. 따라서 인덱스가 너무 많거나 업데이트가 빈번한 경우, 인덱스 유지 비용이 증가하여 전체적인 성능을 저하시킬 수 있습니다.

- 2. 인덱스 선택 및 설계 오류: 
   적절한 인덱스 선택과 설계가 중요합니다. 잘못된 인덱스 설계는 쿼리 실행 계획을 방해하거나 인덱스를 효과적으로 활용하지 못하게 할 수 있습니다. 불필요한 인덱스, 중복된 인덱스, 인덱스의 순서 등의 오류를 피해야 합니다.

- 3. 대규모 데이터에서는 오히려 Full Scan이 유리한 경우도 존재합니다. 

### Q) 클러스터링, 논클러스터링 인덱스의 성능 상 차이와 인덱스를 통해 데이터에 접근하는 과정에서의 차이를 설명해주세요.
  ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/aa9832af-265e-4eef-9450-c3ea4582209f)

  - 클러스터링 인덱스(Clustered Index)와 논클러스터링 인덱스(Non-Clustered Index)는 데이터베이스에서 데이터의 빠른 검색을 위해 사용되는 인덱스 유형입니다. 이 두 인덱스는 데이터의 물리적인 저장 구조와 검색 방식에 차이가 있습니다.

  **클러스터링 인덱스 (Clustered Index)**
  - 클러스터링 인덱스는 테이블의 레코드들을 물리적으로 정렬된 상태로 저장하는 인덱스입니다.
  - 테이블당 하나의 클러스터링 인덱스만 가질 수 있습니다.
  - 클러스터링 인덱스를 구성하는 열은 데이터베이스 테이블에서 주 키(primary key) 또는 - - - 고유한 키(unique key)로 지정되어야 합니다.
  - 클러스터링 인덱스를 통해 데이터는 해당 인덱스의 정렬 순서대로 빠르게 액세스될 수 있습니다.
  - 클러스터링 인덱스의 장점은 검색 성능이 우수하며 범위 검색에 효과적입니다. 데이터의 
  - 물리적인 정렬로 인해 연속된 블록으로 데이터에 접근할 수 있기 때문입니다.

  **논클러스터링 인덱스 (Non-Clustered Index)**
  - 논클러스터링 인덱스는 테이블의 별도의 구조로 데이터를 저장하는 인덱스입니다.
  - 테이블당 여러 개의 논클러스터링 인덱스를 가질 수 있습니다.
  - 논클러스터링 인덱스는 테이블의 컬럼이나 컬럼 조합에 대해 생성될 수 있습니다.
  - 논클러스터링 인덱스는 데이터의 행(row)을 찾는 데 사용되며, 행의 실제 데이터를 찾기 위해 별도의 I/O 작업이 필요합니다.
  - 논클러스터링 인덱스의 장점은 검색된 행을 찾기 위한 추가적인 I/O 비용을 감소시킬 수 있다는 것입니다. 
  - 특정 컬럼이나 컬럼 조합에 대해 빠른 검색을 제공합니다.

  1. **성능 차이**

  - **클러스터링 인덱스**
    클러스터링 인덱스는 데이터를 물리적으로 정렬된 상태로 유지합니다. 테이블의 클러스터링 인덱스는 주로 테이블의 프라이머리 키를 기반으로 생성됩니다. 따라서 데이터베이스에서 특정 테이블에 대한 클러스터링 인덱스를 가지고 있다면, 해당 테이블의 물리적인 데이터 저장 구조는 인덱스의 키 순서로 정렬됩니다. 이로 인해 특정 범위의 데이터에 대한 쿼리를 수행할 때 성능이 향상될 수 있습니다.
  - **논클러스터링 인덱스**
    논클러스터링 인덱스는 데이터의 논리적인 순서를 유지하지만, 물리적인 순서는 유지하지 않습니다. 이러한 인덱스는 테이블의 보조 인덱스로 생성되며, 프라이머리 키 이외의 열을 기반으로 합니다. 논클러스터링 인덱스를 사용하면 특정 열이나 열의 조합을 검색할 때 더 효율적인 성능을 제공할 수 있습니다.

  2. **데이터 접근 과정 차이**

  - **클러스터링 인덱스**
    클러스터링 인덱스는 데이터의 물리적인 정렬을 변경하기 때문에 인덱스 키의 순서에 따라 데이터에 직접 접근할 수 있습니다. 따라서 클러스터링 인덱스를 통해 데이터에 접근하면 인덱스의 키 값과 일치하는 데이터를 물리적으로 연속된 위치에서 검색할 수 있습니다.

  - **논클러스터링 인덱스**
    논클러스터링 인덱스는 데이터의 논리적인 순서를 유지하지만, 물리적인 정렬을 변경하지 않습니다. 논클러스터링 인덱스를 통해 데이터에 접근하면 인덱스 키 값과 일치하는 행을 찾고, 해당 행의 물리적인 위치를 식별한 후 데이터에 접근해야 합니다. 따라서 논클러스터링 인덱스를 통한 데이터 접근은 추가적인 I/O 작업이 필요할 수 있습니다.


### Q) 복합키를 PK로 잡을 때 인덱스 관련해서 주의해야 할 사항이 있을까요?
- 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치(순서)가 상당히 중요하며 또한 아주 신중히 결정해야 합니다.
- 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬돼 있다는 것입니다. 즉, **두 번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다는 것**입니다. 
- 만약 컬럼이 4개인 인덱스를 생성한다면 세 번째 컬럼은 두 번째 컬럼에 의존해서 정렬되고 네 번째 컬럼은 다시 세 번째 컬럼에 의존해서 정렬될 것입니다. 
- 만약 SUBSIDIRARY_ID 값의 정렬 순서가 빠르다 하더라도 EMPLOYEE_ID 컬럼의 정렬 순서가 늦다면 인덱스의 뒤쪽에 위치하게 됩니다. 
- 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치(순서)가 상당히 중요하며 또한 아주 신중히 결정해야 하는 이유가 바로 여기에 있습니다.
 

### Q) 인덱스 스캔 VS 풀 스캔 
  - 인덱스 스캔이 테이블 풀 스캔에 비해 반드시 유리하진 않습니다. 
  -  인덱스를 사용하는 것이 항상 좋아 보일 수도 있지만, 인덱스는 single block io를 통해서 데이터에 접근합니다. 
  - 따라서, 쿼리에 걸리는 항목들이 많은 경우에는 많은 블록을 한 번에 불러 올 수 있음에도 불구하고 한 블록씩 읽어 오는 비효율을 야기할 수 있습니다. 이러한 이유로 모든 경우에 인덱스를 사용하는 것은 결코 좋은 선택이 아닐 수 있습니다.

  1. 인덱스 스캔은 Random access인 반면, 테이블 풀 스캔은 Sequential access입니다. 
  2. 인덱스 스캔은 Single Block I/O 인 반면, 테이블 풀 스캔은 Multi Block I/O 읽기 방식을 취합니다.

  - **Single Block** : 한 번에 하나의 블록을 읽기 위해서 디스크 I/O를 하는 것을 말합니다. 읽고난 후에는 데이터가 DB Buffer cache에 올라가게 됩니다. single block I/O는 아래의 경우에 일어납니다.

  - **Multi Block** : 한 번에 여러 블록을 디스크로 부터 I/O 하는 것을 말합니다. 읽은 블록은 마찬가지로 DB Buffer Cache에 캐싱 됩니다. Multi Block I/O는 주로 Table Full Scan을 할 때 일어나는데, 이는 Table Full Scan 시에 **하나의 블록을 읽은 후, 다음 불록을 읽는 방식 때문에 어찌보면 한 번에 다음에 읽을 블록들을 미리 읽는 것이 당연한 효율적인 선택**으로 보입니다. 
    OS의 파일 시스템에서는 하나 혹은 연속된 섹터들의 모음인 클러스터를 기준으로 하는 512byte 혹은 4k 사이즈의 "블록"입니다. OS에서는 I/O의 최소 크기가 fileSystem에서 사용하는 하나의 블록이고 최대 크기는 OS 별로 다르지만, 리눅스 커널의 경우 1mb로 정해져 있습니다. 떄문에 한 번의 read request를 보낼 때는, dbms의 블록을 8k라고 가정할 떄,  최대 128개의 블록을 같이 읽어 올 수 있습니다.  
    
  3. 대규모 데이터를 읽게 되면 인덱스 스캔의 성능은 풀 스캔의 성능에 비해 급감합니다.
  ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/9894ceb2-958c-414c-bdb0-943a109acec5)


### 인덱스 알고리즘 종류 추가 정리 

1. B-Tree 인덱스 알고리즘
  ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/4973b8f4-47e2-4943-92bf-d60dd62bfa82)
  - B-Tree 는 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태 
  - 트리 구조의 가장 하위에는 리프 노드라고
  - 트리구조에서 루트노드도 아니고 리프노드도 아닌 중간의 노드를 브랜치 노드라고 한다. 

  - 장점 : 어떤 데이터를 조회하든지, 이에 사용하는 조회 과정의 길이 및 비용이 균등 하다는데 있다.

  - 단점 : 어떤 데이터를 조회 하든지 Root 에서 부터 Leaf 페이지를 모두 거처야 하기 때문에 데이터가 적은 테이블등의 단순 조회로 데이터를 조회하는 과정이 대비 조회 속도가 느린 단점이 있다.

2. Hash Index 
  ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/8ed909b7-90b7-40e3-a6ef-b2ef0cf27b09)

  - Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
  - 값을 변형해서 인덱싱하므로, 해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용 할 수 없다. 

  - 장점 : 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠르고 원래의 키값을 저장하는 것이 아니라 해시 함수의 결과만을 저장하므로 키 컬럼의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 4~8바이트 수준으로 상당히 줄어든다.
   따라서 타 인덱스 대비 조회 속도가 매우 빠르다. 
  
  - 단점 :  각 해쉬값에 주소값을 배정하는 인덱스의 특징에 따라 범위로 조회하는 작업은 느리다. 또한 범위로 묶어서 보관하는 인덱스가 아니므로 데이터 개수가 증가 함에 따라 범위로 묶어서 보관하는 인덱스보다 더 큰 저장공간을 필요로 한다.


### 인상 깊었던 랜덤 I/O와 순차 I/O 추가 정리 
  ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/d400e6b4-9511-4f96-a00a-ba0d16076a1a)

  - 순차 I/O는 연속된 3개의 페이지를 접근하게 되는 방식이라 디스크에 기록하기 위해 한번 시스템 콜을 요청하지만 
  - 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템 콜을 하게 되는 방식이 됩니다. 
  - 즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고, 랜덤 I/O는 디스크 헤드를 3번 움직인 것입니다. 
  - 디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정됩니다. 
  - 결국 여기서 제시한 예에서는 순차 I/O가 랜덤 I/O보다 거의 3배 정도 빠르다고 볼 수 있습니다. 
  - 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 
  - 풀 테이블 스캔은 순차 I/O를 사용합니다. 
  - 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있습니다. 
  - 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문입니다. 
  - OLTP(On-Line Transaction Processing) (데이터 갱신위주) 데이터갱신 위주 성격의 웹서비스보다는 데이터 웨어하우스(데이터 조회위주)나 통계 작업(데이터 조회위주)에서 자주 사용됩니다.

**< 인덱스 레인지 스캔 >**  
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식입니다. 
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현합니다. 
- 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 실제로 원하는 시작 지점을 찾을 수 있습니다. 
- 일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 됩니다. 
- 이처럼 차례대로 쭉 읽는 것을 스캔이라고 표현합니다. 
- 만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔합니다. 
- 그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝냅니다. 
- B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많습니다. 
- B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 특정 검색(스캔) 시작 값을 가지고 있는 리프 노드를 검색하고, 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어 나가는 과정을 확인할 수 있습니다. 
- 가장 중요한 것은 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다는 것입니다. 
- 이는 별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 됩니다
- 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다는 것입니다. 
- 이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, **레코드 한건 한건 단위로 랜덤 I/O가 한번씩 실행**됩니다. 
- 만약 3건의 레코드가 검색 조건에 일치했다고 가정하면 데이터 레코드를 읽기 위해 랜덤 I/O가 최대 3번이 필요하게 됩니다. 
- 그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류되는 것입니다. 
- 그리고 인덱스를 통해 읽어야 할 **데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식**이 되는 것입니다.

### 내용 및 사진 출처 

https://m.blog.naver.com/whdgml1996/222121992033

https://debaeloper.tistory.com/3

https://seokrae.gitbook.io/sr/book/tune/_5

https://m.blog.naver.com/adamdoha/222130707206

https://poododang.tistory.com/entry/effective-sql-10

https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

https://12bme.tistory.com/138?category=682920 (인덱스 전반 정리, 복합키)
