# 클러스터링
  - 동일한 데이터베이스를 여러 대의 서버가 관리하도록 클러스터를 구축하는 것.
  - 클러스터링을 이용함으로써 하나의 서버에 몰리던 부하를 여러 곳으로 분산 시키는 로드 밸런싱이 가능해집니다.

#### 클러스터링의 종류
1. **Active-Active 방식**
  - Active-Active 방식은 동일한 데이터 베이스를 여러 대의 서버가 관리하도록 하는 상태에서, 관리하는 서버들을 모두 켜놓는 상태를 말합니다.
  **[장점]** : 하나의 데이터베이스 서버가 죽더라도 바로 다른 데이터베이스에서 필요한 작업을 수행하면 되기 때문에 클라이언트 입장에서는 서버의 문제가 없는 것처럼 받아들일 수 있고, 안정적인 서비스를 운영 할 수 있습니다.   
  **[단점]** : 여러 대의 서버가 데이터베이스를 공유하므로 병목현상이 발생해서 더 많은 비용이 발생할 수 있고, 여러 개의 서버를 지속적으로 운영하는 과정에서 서버 비용이 많이 소모될 수 있습니다.
2. **Active-StandBy 방식**
  - Active-Active 방식과 달리 모든 서버를 열어두는 것이 아니고, 주 서버를 Active 상태로 유지를 하다가 Active 상태에 문제가 생기면 StandBy 즉, 실행중이지 않고 대기중이었던 데이터베이스 서버를 Active 상태로 전환해서 사용하는 방식입니다. 이러한 방식을 **FailOver** 방식이라고 합니다.
  **[장점]** : 기존의 Active-Active 방식에 비해서 상대적으로 비용이 덜 들게 되고 병목현상도 덜 발생하게 됩니다.
  **[단점]** : Acitve 서버가 문제가 발생했을 경우 StandBy 서버를 Active 서버로 전환하는데에 시간이 소요되어 그 기간동안 클라이언트들은 서비스를 이용할 수 없다는 문제가 있고, Active-Active 방식에 비해서 로드 밸런싱 효율도 떨어진다는 문제가 있습니다.

### Q) 레디스 클러스터링 방식
  - Redis Cluster 방식은 데이터를 자동으로 여러 개의 Redis 노드에 나누어 저장할 수 있는 방법을 제공합니다. 이때, 일부 노드가 죽거나 통신이 되지 않을 때에도 작업을 계속 할 수 있는 가용성을 제공합니다.
  - 단, 과반수의 master 노드가 죽는 경우에는 클러스터도 중단됩니다.
  - Redis 6.0 부터 ThreadedIO가 추가되어 사용자 명령에 대해서는 멀티 쓰레드가 지원되지만, 명령어를 실행하는 코어 부분은 싱글 쓰레드로 동작합니다. 

# 리플리케이션
  - 리플리케이션은 복제된 데이터베이스를 운용하는 방식입니다.
  - 이때, 원본 데이터베이스를 Master, 복제된 데이터베이스를 Slave라고 부릅니다. Slave 데이터베이스는 Master 데이터베이스를 복제하여 동일한 데이터를 가지게 됩니다.   

  **[장점]**
  1. 리플리케이션은 Master 데이터베이스와 Slave 데이터베이스에 각기 다른 명령을 수행하도록 할 수 있습니다. 이로 인해, Insert, Update, Delete 등의 무거운 작업은 Master에 일임하고, Select 같이 가벼운 작업은 Slave에 일임해 부하를 분산시킬 수 있습니다.
  2. 리플리케이션을 이용하면 데이터 안정성을 획득할 수 있고, Master 데이터베이스의 데이터가 손상되었을 때 Slave 데이터베이스에 복제된 데이터를 통하여 복구할 수 있습니다.   

  **[단점]**
  1. Slave에 Master의 데이터를 복제할 때 비동기로 동기화가 됩니다. 이에 따라 데이터의 일관성이 깨질 수 있는 상황이 생길 수도 있습니다. 이때, 복제를 하기 위해 Binary Log 를 사용합니다. 

### Q) 무거운 연산과 가벼운 연산이 무엇인지에 대해서 설명해주세요.
- 무거운 연산은 주로 CREATE, DELETE, UPDATE 등을 의미하고, 가벼운 연산은 SELECT를 의미합니다.

### Q) MYSQL 데이터베이스 리플리케이션 실행 방식에 대해서 설명해주세요.
  1. **Async Replication**
  - MySQL이 기본적으로 채택하는 Replication 방식이고, Binary Log을 사용하여 복제를 합니다. Binary Log에는 MySQL의 모든 변경 사항이 기록이 되고, Slave DB가 이 Binary Log를 이용하여 Replication을 수행하는 방식입니다. 
  - 하지만, replicaiton이 async 방식으로 동작해서 Master 에서는 Slave의 복제 여부등을 확인하지 않아 데이터 일관성 문제를 발생할 수가 있고, Slave의 부하 정도, 시스템 사용륭, 네트워크 속도 등 여러가지 이유로 Replication이 지연될 수 있습니다.

  2. **Semi-Sync Replication**
  - MySQL 5.5 버전에서 도입된 방식입니다. Master DB에서 Slave로 전달된 Relay log의 기록이 완료되었다는 메시지를 받고나서 처리중인 트랜잭션의 결과를 클라이언트에게 반환합니다.
  - Async 방식에 비하면 성능이 저하되지만 완전한 sync 방식 보다는 성능 저하가 덜하고, 변경이 전달된 이후에 클라이언트에게 결과를 반환하기 때문에, 데이터 동기화를 더욱 보장해 줄 수 있습니다.

  3. **binlog**
  - Binary log는 DDL 과 DML 같이 데이터베이스 내에서 발생하는 변경 내역들이 저장되는 로그 파일 입니다.
  - 이러한 로그 파일은 **row, mixed, statement** 3가지 포맷을 가지고 있습니다.
  1. **statement** : 전통적으로 사용하던 방식으로 실행된 쿼리 구문 그대로 Binlog에 남겨지는 방식
  2. **row** : 생성/변경된 데이터의 Before/After row image가 binlog에 저장하여, 사이즈가 statement보다 크게 생성
  3. **mixed** : row와 statement 중간 형태로 날짜와 같이 determine이 필요한 경우 row형태로 저장되는 형식 

### Q) 클러스터링과 리플리케이션의 차이점에 대해서 설명해주세요.
- 클러스터링은 동일한 데이터베이스를 각 다른 서버에서 관리하는 방식이고, 리플리케이션은 동일한 데이터베이스를 하나의 서버에서 데이터베이스를 복제해서 사용하는 방식으로 사용합니다.
  ### Q-1) 동기, 비동기 관점에서도 설명해주세요.
  - 이때, 클러스터링은 같은 데이터베이스를 단순히 각기 다른 서버에서 관리를 하다보니, 동기로 동작하고 리플리케이션은 동일한 서버에서 데이터베이스를 복제해서 사용하므로, Master 데이터베이스를 Slave 데이터베이스에 데이터를 복제하는 과정이 필요해서 비동기로 동작합니다.

  ### Q-2) 클러스터링과 리플리케이션은 각각 어느 상황에서 사용하는 것이 좋을까?.
  - 클러스터링은 리플리케이션에 비해서 가용성 측면에서 많은 장점을 가져다주고 추가적으로 부하 분산을 위한 로드밸런싱도 리플리케이션에 비해서 좋기 때문에 안정적인 서비스를 하기 위한 목적이라면 클러스터링을 사용합니다.
  - 리플리케이션은 서버는 안정적이지만 무거운 쿼리에 대한 응답 속도를 높이고 이에 따라 부하를 분산 시켜 성능 최적화를 하고 싶을 때 사용하는 것이 좋습니다.

### Q) 분산 락을 어떻게 구현 할 것 같은지 답변을 해주세요.
  - 제 3의 서버로 레디스를 두고 분산 데이터베이스에 락에 대해서 락을 레디스에서 잠궈두고 구독자-발행자 패턴을 사용하여 락이 풀리게 되면 그때 제일 처음 진입한 구독자에 대해서 락 권한을 주어 접근 할 수 있도록 합니다.
  - 혹은 낙관적 락을 택하고, 트랜잭션을 수행하면서 데이터의 불일치성이 발견되면 그 떄, 애플리케이션 단계에서 연쇄 롤백을 처리하는 방법도 있습니다. 하지만 이는 구현하기가 복잡하고, 클라이언트에게 안 좋은 서비스 경험도 줄 수 있습니다. 

### Q) GTID가 무엇인지 설명해주세요.
- GTID는 Global Transaction IDentifier의 약자로 MySQL 데이터베이스에서 커밋되는 각 트랜잭션과 함께 생성되고 트랜잭션에 연결되는 고유한 식별자를 의미합니다.
- 이 식별자는 Master서버 뿐만 아니라 복제 대상에 속하는 Replica(Slave)서버에서도 고유합니다.
- 따라서, Master의 트랜잭션 복제 시 Biglog 파일에 pos 정보 대신에 GTID를 사용하여, master-slave의 일관성을 쉽게 확인 할 수 있습니다.

### 참고 자료
[클러스터링, 리플리케이션](https://code-lab1.tistory.com/205)
[레디스 클러스터링](https://velog.io/@tngusqkr1/Redis-cluster-%EC%84%A4%EC%A0%95-1)
[MySQL 리플리케이션 방식](https://hoing.io/archives/3111)
[GTID](https://hoing.io/archives/18445)