# Cookie, Session, OAuth, JWT

**쿠키(Cookie)**
- 쿠키는 클라이언트(웹 브라우저)에 저장되는 작은 데이터 조각으로, 웹 서버는 클라이언트에 쿠키를 생성하여 상태 유지, 개인화, 성능 개선 등의 목적으로 사용할 수 있습니다. 
- 쿠키는 클라이언트의 요청과 응답 헤더에 포함되어 서버와 클라이언트 간의 상태를 유지하며, 보안 관련 옵션을 설정하여 쿠키의 안전성을 강화할 수 있습니다.

**세션(Session)**
- 세션은 서버 측에서 사용자의 상태를 유지하는 데 사용되는 메커니즘입니다. 
- 세션은 일반적으로 서버에서 고유한 식별자(Session ID)를 생성하고, 해당 식별자를 클라이언트에게 쿠키를 통해 전달하여 사용자를 식별합니다. 서버는 세션 ID를 사용하여 해당 세션과 관련된 데이터를 저장하고 조회합니다. 
- 세션은 쿠키와 밀접한 관련이 있으며, 쿠키를 통해 세션 ID를 전달하는 방식이 일반적으로 사용됩니다.

**OAuth**
- OAuth는 제3자 인증을 위한 개방형 인증 및 인가 프로토콜입니다. 
- OAuth는 사용자가 한 서비스(클라이언트)의 인증 정보를 다른 서비스(서비스 제공자)와 공유할 수 있도록 허용하여, 사용자의 인증 정보를 안전하게 공유하고 액세스 권한을 부여하는 프로세스를 제공합니다. 
- OAuth는 사용자가 서비스 제공자의 인증 정보를 공유함으로써, 클라이언트가 제한적인 범위 내에서 사용자의 계정에 대한 액세스 권한을 얻을 수 있도록 합니다.

**JWT (JSON Web Token)**
- JWT는 웹 표준으로 정의된 토큰 기반의 인증 방식입니다. 
- JWT는 JSON 형식으로 정보를 암호화하여 토큰으로 생성하며, 클라이언트와 서버 간에 인증과 정보 교류에 사용됩니다. 
- JWT는 **토큰 자체에 정보를 포함**하고 있어 서버에서 별도의 세션 저장소를 필요로하지 않으며, 클라이언트 측에서 토큰을 저장하여 사용합니다. JWT는 클라이언트가 발급한 토큰을 서버에서 검증하고 신뢰함으로써 인증 및 권한 부여를 수행합니다.

### Q) 쿠키와 세션의 만료 시간에 대해 설명해주세요
- **쿠키(Cookie)의 만료 시간**
- 쿠키는 보통 클라이언트의 로컬에 저장되며, 만료 시간을 설정하여 유효 기간을 제어할 수 있습니다. 
- 쿠키의 만료 시간을 설정하지 않으면 브라우저 세션(session) 동안만 유효하며, 사용자가 브라우저를 종료하면 삭제됩니다. 
- 하지만 만료 시간을 설정하면 쿠키는 설정된 만료 일자/시간까지 유지됩니다. 클라이언트가 다시 서버에 요청할 때마다 해당 쿠키는 서버로 함께 전송됩니다.

- **세션(Session)의 만료 시간**
- 세션의 만료 시간은 서버 측에서 설정됩니다. 
- 만료 시간을 설정하면 일정 기간 동안 유효한 세션으로 유지되며, 만료 시간이 지나면 세션 데이터는 삭제됩니다.
- 사용자가 웹 애플리케이션에서 일정 기간 동안 활동하지 않으면 세션이 만료되는 경우가 많습니다. 세션이 만료되면 사용자는 다시 인증을 수행해야 합니다.

    ### Q-1) 세션은 왜 브라우저가 닫힐 때 만료되나요?
    **1. 세션 식별자 정보 유출 방지**
    - 세션은 서버 측에 저장되는 데이터입니다. 
    - 클라이언트(브라우저)가 닫힐 경우, 클라이언트와 연결된 세션 데이터가 서버에 대한 연결이 끊기고 삭제되는 것이 일반적입니다. 
    - 이로 인해 클라이언트 측에서 세션 식별자 정보가 유출되는 위험이 줄어듭니다.

    **2. 보안 및 개인 정보 보호** 
    - 세션은 사용자의 인증 상태와 관련된 중요한 정보를 포함할 수 있습니다. 
    - 브라우저가 닫히면 해당 세션은 사용자의 로그아웃 상태로 간주되고, 다음에 새로운 세션을 시작해야 합니다. 
    - 이를 통해 다른 사람이 사용자의 컴퓨터를 접근하여 세션 데이터를 사용하는 등의 보안 및 개인 정보 유출 위험을 줄일 수 있습니다.

    **3. 세션 관리 및 자원 절약** 
    - 세션은 서버 측에서 관리되는 자원입니다. 
    - 브라우저가 닫힐 때 세션을 만료시키면, 서버는 더 이상 해당 세션에 대한 자원을 할당하지 않아도 됩니다. 
    - 이는 서버 자원을 효율적으로 관리하고 성능을 향상시키는 데 도움이 됩니다.

### Q) 쿠키와 세션을 각각 어느 상황에 사용하실 건지 설명해주세요.
- 세션의 단점은 매번 서버에서 저장하고 관리해줘야 한다는 점입니다. 따라서 보안성이 뛰어나다고 세션만 사용하기보다 세션과 쿠키를 적재적소에 사용하는 것이 중요합니다. 

1. 쿠키(Cookie)의 사용 

- **로그인 정보 유지**
쿠키는 로그인 정보를 클라이언트(브라우저)에 저장하여 다음에 애플리케이션에 접속할 때 자동으로 로그인되도록 할 수 있습니다. 사용자가 "로그인 상태 유지" 옵션을 선택하면 쿠키에 인증 토큰 또는 세션 ID를 저장하여 재인증 없이 애플리케이션에 접근할 수 있습니다.

- **사용자 환경 설정 저장**
쿠키는 사용자가 애플리케이션 내에서 선호하는 설정(언어, 테마 등)을 저장하는 데 사용될 수 있습니다. 이를 통해 사용자의 환경 설정을 기억하고, 다음에 접속할 때 해당 설정을 자동으로 적용할 수 있습니다.

- **개인화된 콘텐츠 제공**
쿠키는 사용자의 이전 상호작용과 행동을 추적하여 개인화된 콘텐츠를 제공하는 데 사용될 수 있습니다. 예를 들어, 사용자가 이전에 본 항목, 관심사, 구매 이력 등을 쿠키에 저장하여 해당 정보를 기반으로 추천 콘텐츠를 제공할 수 있습니다.

2. 세션(Session)의 사용 시나리오:

**사용자 인증 및 권한 관리**
세션은 사용자가 인증되고 권한이 부여된 상태를 유지하는 데 사용됩니다. 사용자가 로그인하면 세션을 생성하고, 세션 데이터에 사용자 정보 및 권한 정보를 저장하여 해당 세션을 통해 사용자의 인증 상태를 관리합니다.

### Q) 세션의 보안적인 문제를 설명해주세요.

- **세션 하이재킹(Session Hijacking)**
   - 세션 하이재킹은 공격자가 세션 식별자(Session ID)를 획득하여 해당 세션을 도용하는 공격입니다. 공격자가 세션 식별자를 획득하면, 해당 세션을 사용하여 사용자로 위장하여 악의적인 활동을 할 수 있습니다.

- **세션 하이재킹 대응방법**
1. HTTPS와 같은 암호화된 연결을 사용
- 세션 데이터를 암호화해야 합니다. 암호화된 연결은 데이터를 보호하고 중간에 가로채어질 수 있는 위험을 줄여줍니다.
2. 세션 타임아웃 
- 웹 애플리케이션에서 세션의 유효 시간을 설정하는 메커니즘입니다. 세션 타임아웃은 일정 시간 동안 사용자의 활동이 없을 경우 세션을 만료시키는 것을 의미합니다
- 사용자가 일정 시간 동안 애플리케이션을 사용하지 않을 때, 세션은 자동으로 종료되고 세션 데이터는 삭제됩니다. 이는 세션 하이재킹(Session Hijacking)과 같은 공격을 어렵게 만들고 사용자의 인증 정보를 보호하는 데 도움이 됩니다.
- (+) 자원 절약의 효과 : 세션 타임아웃은 서버 자원을 효율적으로 관리하는 데 도움이 됩니다. 세션 데이터는 서버 메모리 또는 데이터베이스에 저장되므로, 사용자가 애플리케이션을 사용하지 않으면 해당 세션에 대한 자원을 계속 유지할 필요가 없습니다. 세션 타임아웃은 유휴 세션을 자동으로 종료하여 자원을 확보할 수 있습니다.

### Q) 쿠키를 사용하는 이유에 대해 설명해주세요.
- **상태 유지**
쿠키는 사용자의 상태를 유지하기 위해 사용됩니다. 예를 들어, 로그인 세션을 유지하거나 사용자의 환경 설정(언어, 테마, 글꼴 크기 등)을 저장하여 사용자가 웹 애플리케이션을 이용하는 동안 일관된 경험을 제공할 수 있습니다.

- **개인화**
쿠키는 사용자에게 개인화된 콘텐츠를 제공하기 위해 사용될 수 있습니다. 사용자의 이전 상호작용과 행동을 추적하고, 해당 정보를 쿠키에 저장하여 개인화된 광고, 추천 콘텐츠, 사용자 맞춤 설정 등을 제공할 수 있습니다.

- **성능 개선**
쿠키는 웹 애플리케이션의 성능을 개선하는 데 사용될 수 있습니다. 쿠키를 사용하여 사용자의 선호하는 콘텐츠를 미리 로드하거나, 사용자가 방문하는 페이지를 추적하여 캐싱이나 프리로딩 등의 기술을 적용할 수 있습니다.

- **트래킹 및 분석**
쿠키는 웹 사이트의 트래킹과 사용자 동작 분석을 위해 사용될 수 있습니다. 쿠키를 통해 사용자의 방문 패턴, 클릭 동작, 구매 기록 등을 추적하고 분석하여 마케팅 전략, 개선점, 사용자 행동 패턴 등에 대한 통계 및 인사이트를 얻을 수 있습니다.

### Q) 세션은 서버에서 어디에 저장될까요? 

- 세션 데이터는 서버 측에 저장됩니다. 세션 데이터는 일반적으로 서버의 메모리, 데이터베이스, 파일 시스템 등의 지속적인 저장소에 저장됩니다.

1. **메모리**
- 서버의 메모리에 세션 데이터를 저장하는 방식입니다. 
- 메모리에 저장되는 세션은 빠른 응답 속도를 제공하며, 데이터의 신속한 접근과 수정이 가능합니다. 
- 하지만 서버 재시작이나 장애 시 세션 데이터가 손실될 수 있습니다.

2. **데이터베이스**
- 세션 데이터를 데이터베이스에 저장하는 방식입니다. 
- 데이터베이스는 보다 영구적인 저장소로서 세션 데이터의 지속성을 보장합니다. 
- 데이터베이스를 사용하면 세션 데이터의 백업, 복구, 확장성 등을 관리할 수 있습니다. 
- 하지만 데이터베이스 액세스의 오버헤드로 인해 성능이 약간 저하될 수 있습니다.

3. **파일 시스템**
- 세션 데이터를 파일 시스템에 저장하는 방식입니다. 
- 파일 시스템은 각 세션에 대한 별도의 파일을 생성하여 세션 데이터를 저장합니다. 
- 파일 시스템을 사용하면 데이터의 지속성을 보장하면서도 상대적으로 간단하게 구현할 수 있습니다. 
- 그러나 파일 액세스의 오버헤드로 인해 성능 저하가 발생할 수 있습니다.
- 쿠키는 ~ 에서 저장됩니다.

    ### Q-1) 한 사이트에서 100만개 정도의 세션을 생성해야 하는 경우엔 어떻게 세션을 저장해야 하나요?

    - 1. **데이터베이스 저장소**
       - 대규모 세션 관리를 위해 데이터베이스를 사용하는 것이 일반적으로 가장 효과적입니다. 데이터베이스는 세션 데이터의 지속성을 보장하며, 고성능 및 확장성을 제공할 수 있습니다. 데이터베이스를 사용하면 클러스터링, 복제, 분산 데이터베이스 등을 활용하여 세션 데이터를 효율적으로 관리할 수 있습니다.

    - 2. **분산 캐시 (세션 스토리지 구성)**
       - 분산 캐시 시스템을 사용하여 세션 데이터를 저장할 수도 있습니다. 분산 캐시는 메모리 기반으로 동작하며, 빠른 응답 시간과 확장성을 제공합니다. 대규모 세션 관리를 위해 Redis, Memcached와 같은 분산 캐시 시스템을 사용할 수 있습니다.

    - 3. **메모리 관리**
       - 일부 경우에는 세션 데이터를 서버의 메모리에 직접 저장할 수도 있습니다. 이 경우에는 메모리의 용량과 성능을 고려해야 합니다. 대규모 세션 관리를 위해 메모리 관리 시스템을 사용하거나, 메모리 저장소를 확장하는 기술을 고려할 수 있습니다. 
    
    ### Q-2) 서버 쪽에서 세션 아이디가 만료되는 시점을 알 필요가 있을 것 같습니다. 이를 고려해서 세션을 설계한다면 어떻게 설계해야 할까요?
    - 쿠키 `set-max-age` 에 시간을 설정해두고, 클라이언트가 이 쿠키를 전송할 때마다 max-age를 갱신해줍니다. 
    - 그러다가 클라이언트가 일정 기간 요청을 보내지 않으면 세션은 age가 갱신되지 않을 것이고, max-age 시간이 만료되어 세션은 만료됩니다. 


### Q) JWT 토큰의 장단점에 대해 설명해주세요.

- **장점**
   - 간결하고 가볍습니다: JWT는 JSON 형식을 사용하며, 토큰 자체에 필요한 정보를 포함하므로 별도의 데이터베이스 조회 없이 토큰을 검증할 수 있습니다. 이로 인해 토큰의 크기가 작아지고, 네트워크 부하를 줄일 수 있습니다.

   - 확장 가능성이 높습니다: JWT는 토큰 내에 클레임(claim)이라는 추가 정보를 포함할 수 있습니다. 클레임은 토큰의 발급자, 만료일, 권한 등을 나타내며, 필요에 따라 확장할 수 있습니다.

   - 분산 아키텍처를 지원합니다: JWT는 서버의 상태를 저장하지 않고 토큰 자체에 모든 필요한 정보를 포함하기 때문에, 로드 밸런싱 된 서버나 다중 서버 아키텍처에서 효율적으로 사용할 수 있습니다.

   - 클라이언트 측 인증을 지원합니다: JWT는 토큰을 클라이언트에 저장하고 인증할 수 있으므로, 클라이언트 측에서 사용자 인증을 처리하는 데 유용합니다. 서버에서는 세션 상태를 유지할 필요가 없으므로 확장성이 향상됩니다.

- **단점**
   - 토큰의 크기가 커질 수 있습니다: JWT는 토큰에 필요한 모든 정보를 포함하기 때문에, 토큰의 크기가 커질 수 있습니다. 토큰이 모든 요청에 포함되어야 한다면 네트워크 부하가 증가할 수 있습니다.

   - 토큰은 수정할 수 없습니다: 한 번 JWT 토큰이 발급되면 토큰 내의 정보는 변경할 수 없습니다. 토큰에 저장된 클레임이나 만료 일자를 변경하려면 새로운 토큰을 발급해야 합니다.

   - 토큰 만료 관리가 필요합니다: JWT 토큰은 토큰 자체에 만료 일자를 포함하므로, 토큰이 만료되면 다시 발급해야 합니다.

   - 토큰 위조를 방지할 순 없지만 토큰에 담긴 정보를 숨기기는 어렵습니다. 위조같은 경우는 HEADER, PAYLOAD, SIGNATURE 중 SIGNATURE 을 통해 방지할 수 있지만 PAYLOAD에 담긴 정보는 쉽게 복호화가 가능합니다. 

### Q) JSESSIONID 에 대해 설명해주세요.
- JSESSIONID는 Java Servlet 기반 웹 애플리케이션에서 사용되는 세션 식별자입니다. 
- 이는 클라이언트와 서버 간의 상태 유지를 위해 사용되는 쿠키입니다.
- JSESSIONID는 웹 서버가 클라이언트에게 부여하는 고유한 식별자로, 클라이언트가 서버에 요청을 보낼 때 세션을 식별하는 데 사용됩니다.
- 중요한 점은 JSESSIONID는 세션을 식별하는 용도로만 사용되며, 보안을 위해 암호화되지 않습니다.
- 따라서 HTTPS와 같은 안전한 연결을 통해 전송되어야 합니다. 
- 또한, JSESSIONID를 적절하게 관리하여 세션 하이재킹 등의 공격으로부터 보호해야 합니다.

   **< JSESSIONID 작동 과정>**
   - 1. 클라이언트가 웹 서버에 최초로 접속하면, 서버는 클라이언트에게 JSESSIONID 쿠키를 생성하여 응답으로 전송합니다.

   - 2. 클라이언트는 이후의 모든 요청에서 JSESSIONID 쿠키를 서버로 전송합니다. 이를 통해 서버는 클라이언트의 세션을 식별하고 관리할 수 있습니다.

   - 3. 서버는 JSESSIONID를 사용하여 클라이언트의 세션 상태를 유지합니다. 이를 통해 서버는 클라이언트와 상호작용하면서 데이터를 유지하고, 로그인 상태, 장바구니 정보, 선호 설정 등과 같은 개별 사용자 정보를 추적할 수 있습니다.

   ### Q-1) JSESSIONID 생성, 만료 시간에 대해 설명해주세요. 

    **JSESSIONID의 생성**

    - 클라이언트가 최초로 웹 서버에 접속하면, 웹 서버는 새로운 세션을 생성하고 해당 세션에 대한 고유한 JSESSIONID를 생성합니다.

    - JSESSIONID는 일반적으로 랜덤한 값으로 생성됩니다. 예를 들어, 32자의 16진수 문자열로 표현될 수 있습니다.

    - 웹 서버는 생성된 JSESSIONID를 클라이언트에게 응답으로 전송합니다. 이를 위해 쿠키 헤더에 JSESSIONID를 포함하는 Set-Cookie 헤더가 전송됩니다.

    - 클라이언트는 이후의 요청에서 JSESSIONID를 서버로 전송하여 세션을 식별합니다. 일반적으로 쿠키를 통해 JSESSIONID가 전송됩니다.

    **JSESSIONID의 만료 시간**

    - JSESSIONID의 만료 시간은 웹 애플리케이션 서버의 설정에 의해 결정됩니다. 설정은 일반적으로 세션 관리자나 웹 서버의 구성 파일에서 조정할 수 있습니다.

    - 세션의 만료 시간은 두 가지 방식으로 설정할 수 있습니다.

    1. 세션 기간 만료 
    - 일정 시간 동안 클라이언트의 요청이 없으면 세션을 만료시킵니다. 
    - 클라이언트가 일정 시간 동안 요청을 보내지 않으면, 서버는 세션을 만료시키고 JSESSIONID를 무효화합니다. 
    - 이 시간은 일반적으로 웹 서버의 설정 파일에서 조정할 수 있습니다.

    2. 절대적인 만료 시간: 세션을 특정한 시간에 만료시킵니다. 
    - 예를 들어, 세션을 30분 또는 1시간 동안 유지하고 그 이후에 만료시킬 수 있습니다.

   ### Q-2) JSESSIONID는 누가 발급해주나요?
   - JSESSIONID는 웹 애플리케이션 서버(예: Java Servlet 컨테이너)가 발급해줍니다. 
    - 클라이언트가 웹 서버에 최초로 접속할 때, 웹 서버는 JSESSIONID를 생성하고 클라이언트에게 전달합니다. 
    - 이를 통해 서버는 클라이언트와 연결된 세션을 유지하고, 클라이언트의 상태 및 데이터를 식별 및 관리할 수 있습니다.

### Q) COOKIE 의 보안 관련 옵션에 대해 설명해주세요.
- HttpOnly, SameSite, Secure
   ### Q-1) httponly가 언제 쓰여야 하는지 설명해주세요.
   - HttpOnly flag는 쿠키에 접근할 수 있는 방법을 제한하는 옵션입니다. 
   - 이 옵션이 설정된 쿠키는 **JavaScript를 통한 접근이 불가능**하므로, XSS(Cross-Site Scripting) 공격 등으로부터 쿠키를 보호할 수 있습니다. 
   - HttpOnly flag는 클라이언트 측에서 쿠키에 접근하는 것을 제한하고, 서버 측에서만 쿠키에 접근할 수 있도록 합니다.

   ### Q-2) SameSite attribute Option에 대해 설명해주세요.
   - SameSite attribute는 쿠키가 같은 사이트에서만 전송되도록 제한하는 옵션입니다. 
   - SameSite을 "Strict"로 설정하면 외부 사이트에서의 요청에서 쿠키가 전송되지 않으며, "Lax"로 설정하면 외부 사이트에서 GET 메서드로 이루어지는 요청에서만 쿠키가 전송됩니다. 
   - SameSite 옵션은 CSRF(Cross-Site Request Forgery) 공격으로부터 쿠키를 보호하고, 사이트 간 요청 위조를 방지하는 데 도움을 줍니다.

   ### Q-3) Secure Option에 대해 설명해주세요. 
   - 암호화된 HTTPS 연결에서만 전송되도록 지정하는 옵션입니다. 
   - Secure flag가 설정된 쿠키는 암호화되지 않은 HTTP 연결에서는 전송되지 않습니다. 
   - 이를 통해 중간에 가로채어질 수 있는 위험을 줄이고, 쿠키 데이터의 기밀성을 보호할 수 있습니다. - 로그인 정보와 같이 민감한 데이터를 저장하는 경우, Secure flag를 설정하는 것이 좋습니다.

### Q) 쿠키를 클라이언트의 로컬에 저장해두었을 때, 다른 도메인에서 해당 쿠키를 요청하는 상황이 있다면 서버는 어떻게 대처해야 할까요?
- 다른 도메인에서 해당 쿠키를 요청하는 상황의 원인은 서버가 이 쿠키를 읽을 수 있는 특정한 도메인을 지정한 것이 아닌, 모든 도메인에서 이 쿠키를 읽을 수 있다고 지정해주었기 때문입니다.
- 따라서 특정 도메인에서만 쿠키를 읽을 수 있다는 옵션을 지정해주어야 합니다. 
- 쿠키 응답 헤더에 도메인을 지정해주면 됩니다. 


### Q) 요즘 다중 서버 환경이 증가하고 있는데, 이때는 어떻게 세션을 관리해야 할까요?
1. **Sticky Session**
- Sticky Session은 웹 애플리케이션에서 로드 밸런서(Load Balancer)와 같은 중간 계층 장치를 사용하는 경우에 적용되는 세션 관리 방식입니다. 
- Sticky Session은 특정 사용자의 모든 요청이 항상 동일한 서버로 전달되도록 보장하는 메커니즘입니다. 
- 로드 밸런서는 초기 요청 시 사용자에게 세션 ID를 부여하고, 이후의 모든 요청에서는 해당 세션 ID를 기반으로 동일한 서버로 연결합니다. 
- 이를 통해 세션 데이터를 서버가 유지하고, 사용자의 상태를 일관되게 유지할 수 있습니다.

2. **Session Clustering** 
- Session Clustering은 여러 서버 간에 세션 데이터를 공유하여 세션 상태의 일관성을 유지하는 메커니즘입니다. 
- Tomcat에서는 크게 두 가지 방식으로 Session Clustering을 구현 기능을 제공합니다. (All-to-All Session Replication & Primary-Secondary Session Replication)
   - 2-1. All-to-All Session Replication
        ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/cb0d3d37-507d-4fde-811b-4e867abcc28e)
       - All-to-All 방식은 **하나의 세션 클러스터 내에서 데이터가 변경되면 변경된 사항이 다른 모든 서버로 복제** 되는 방식으로, 톰캣에서 제공하는 DeltaManager 클래스를 통해 구현된다.
       - 특정 서버에 생성된 세션을 클러스터를 이루는 모든 서버에 세션을 복제하기 때문에 클라이언트의 요청을 한 곳으로 지정하지 않아도 되고 다른 서버로 요청을 보내더라도 같은 세션을 유지할 수 있다. 
       - 만일 이용하고 있는 서버에 장애가 발생해도 다른 서버에서 세션을 유지하고 있기 때문에 클라이언트는 동일한 서비스 환경을 제공받을 수 있게 된다.
       - 하지만 All-to-All 방식에서는 모든 서버가 전체 세션 데이터를 유지하고 있기 때문에, 다른 서버에서 세션을 찾기 위한 추가적인 네트워트 I/O가 발생하진 않지만, 그만큼 많은 메모리가 필요하다는 단점이 있다.
       - 그리고 세션을 저장할 때 서버 수 만큼 복제하고 각 서버에 전달, 저장해야하기 때문에 서버 수에 비례하여 네트워크 트래픽이 증가하게 되기도 한다.
       - 추가적으로 세션 전파 작업 중 모든 서버에 세션이 전파되기까지의 시간차로 인한 세션 불일치 문제와 같은 예상치 못한 문제가 발생할 가능성이 존재

   - 2-2. Primary-Secondary Session Replication
        ![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/7e63ffc1-5929-4a23-a184-9a3b36586f1f)
        - Primay-Secondary 방식은 **Primary 서버의 세션 데이터를 Secondary(Backup) 서버에만 전체 복제하여 저장하는 방식**으로, BackupManager 클래스를 통해 이 방식을 제공하고 있다.
       - All-to-All Session Replication 방식은 그냥 무식하게 모든 서버에 복제하고 저장하는 것과 달리, Primary 서버와 Secondary(Backup) 서버에만 전체 세션을 복제하여 저장하되, 나머지 이외의 서버들에는 세션의 Key에 해당하는 JSESSIONID만 복제, 저장함으로써 메모리를 절약할 수 있는 방식이다.
       - 하지만 만일 Primary, Secondary 서버를 제외한 다른 서버에 세션 정보를 요청할 경우 다시 온전한 세션 정보를 얻기 위해서는 Primary, Secondary에 다시 요청을 보내야한다는, 세션 복제를 위한 과정이 수행되는 문제점이 존재한다.

3. **Session Storage**

### Q) OAuth 과정 
![image](https://github.com/kim-se-jin/CS-JAVA-Study/assets/76711238/ceb7f005-b18e-4411-b59c-c39a702df613)

1. 클라이언트 애플리케이션 등록:
애플리케이션 개발자는 OAuth 공급자(일반적으로는 인증 서비스 제공자)에게 애플리케이션 등록을 요청합니다. 등록 시에는 애플리케이션의 식별자(Client ID)와 보안 비밀(Client Secret)을 발급받습니다.

2. 사용자 인증 요청:
클라이언트 애플리케이션은 사용자를 인증할 수 있는 수단으로 사용자를 OAuth 공급자의 인증 서비스로 리다이렉트합니다. 이때, 애플리케이션은 사용자 인증 요청에 자신의 Client ID를 함께 전송합니다.

3. 사용자 로그인 및 권한 부여:
사용자는 OAuth 공급자의 인증 서비스에 로그인하고, 클라이언트 애플리케이션이 요청한 액세스 권한을 허용 또는 거부할 수 있는 선택을 합니다.

4. 인증 코드 수령:
사용자가 액세스 권한을 허용한 경우, OAuth 공급자는 클라이언트 애플리케이션에게 인증 코드(Authorization Code)를 발급합니다. 이 인증 코드는 클라이언트 애플리케이션이 액세스 토큰을 요청할 때 사용됩니다.

5. 액세스 토큰 요청:
클라이언트 애플리케이션은 인증 코드와 함께 액세스 토큰을 요청합니다. 이때, 애플리케이션은 자신의 Client ID, Client Secret, 리다이렉트 URI와 함께 요청을 보냅니다.

6. 액세스 토큰 발급:
OAuth 공급자는 클라이언트 애플리케이션에게 유효한 인증 코드와 일치하는 경우, 액세스 토큰을 발급합니다. 액세스 토큰은 사용자가 리소스에 접근할 때 식별 및 인증에 사용됩니다.

7. 액세스 토큰 사용:
클라이언트 애플리케이션은 발급받은 액세스 토큰을 사용하여 OAuth 공급자의 API에 접근합니다. 이를 통해 사용자의 데이터나 리소스를 요청하거나 수정할 수 있습니다. 액세스 토큰은 API 요청의 인증 수단으로 사용되며, 일반적으로 HTTP 헤더에 포함하여 전송됩니다.

8. 리소스 서버 접근:
클라이언트 애플리케이션이 액세스 토큰을 포함한 요청을 리소스 서버에 보냅니다. 리소스 서버는 해당 액세스 토큰의 유효성을 확인하고, 요청된 리소스에 대한 접근 권한을 확인합니다.

9. 리소스 제공:
리소스 서버는 액세스 토큰의 유효성과 권한을 확인한 후, 클라이언트 애플리케이션에게 요청된 리소스를 제공합니다. 이를 통해 클라이언트 애플리케이션은 사용자의 데이터나 서비스에 접근하여 필요한 작업을 수행할 수 있습니다.

10. OAuth 프로토콜을 통해 클라이언트 애플리케이션은 사용자의 인증 정보를 안전하게 보호하고, 사용자의 권한을 효과적으로 관리할 수 있습니다. 또한, 애플리케이션은 사용자의 비밀번호 등 중요한 정보를 저장하거나 관리하지 않아도 되므로 보안상 이점을 가지게 됩니다.

### Q) 자동 로그인 기능을 어떻게 구현하실 건가요? (동일한 유저임을 유이무이하게 판단하는 방법)  
- 사용자의 MAC 주소를 담은 쿠키를 남겨두어 해당 유저임을 식별하면서 자동 로그인을 유지하게 하는 것도 가능할 것 같습니다. 


#### 사진 & 내용 출처

https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-%EC%84%B8%EC%85%98Session-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B2%95-%E2%B8%A2%EC%84%9C%EB%B2%84-%EB%8B%A4%EC%A4%91%ED%99%94-%ED%99%98%EA%B2%BD-%E2%B8%A5#tomcat_session_clustering

https://hudi.blog/oauth-2.0/
