# HTTP & HTTPS

HTTP
- 인터넷에서 클라이언트, 서버간 데이터와 리소스를 교환할수있게 해주는 기본 프로토콜
- 요청과 응답이 이전 요청,응답과 독립적인 stateless한 프로토콜
  
HTTPS
- HTTP에 데이터를 주고받는과정에 보안적인 요소가 추가된 프로토콜

### Q) HTTP의 비연결성과 Stateless에 대해 설명해주세요

- HTTP는 이전 요청과 응답에 독립적인 Stateless한 특징덕분에 확장성과 캐시가능성의 이점이있습니다.
- 각 요청이 독립적이기때문에 서버는 상태정보를 유지할필요가 없으며 이는 리소스를 관리하기 용이해지고 더 많은 요청을 동시에 처리할수있습니다.

- HTTP는 요청과 응답을 주고받은후 연결을 끊는 특성이있습니다.

### Q) HTTP는 항상 Stateless한가요? 상태를 유지해야하는경우는 어떤경우인지 설명해주세요

- 장바구니같이 사용자가 담아둔 정보를 유지해야하는경우가 있을수있는데 이런경우 상태유지를위한 쿠키,세션과같은 개념이 필요합니다.

### Q) 쿠키를 사용했을때 단점에대해 설명해주세요

- 가장 큰 단점은 쿠키의 데이터가 쉽게 노출될수있다는 점이있고 용량 제한이 4KB까지있어서 많은 데이터를 담을순없고, 쿠키사이즈가 커질수록 네트워크 부하가 심해질수있습니다.

> #### Q) 쿠키는 클라이언트 어디에 저장되나요?

서버가 Set-Cookie헤더가 포함된 응답을 클라이언트에 보낸다면 브라우저가 쿠키를 수신해 로컬에 저장합니다. 
브라우저가 쿠키를 저장/관리하게됩니다.

> #### HTTPS 설정하기위한 인증서 발급과정과 서버가 어떻게 인증서 발급받고 사용하는지 설명해주세요

1. CSR(인증서 서명요청)에 도메인이름, 조직세부정보, 서버의 공개키를 담아 생성한다. 

2. 서버에서 CSR을 인증기관에 제출한다. 

3. 인증기관은 유효성을 확인하고 인증서를 발급해준다. 

4. 인증기관으로부터 받은 인증서를 서버에 설치하고 HTTPS연결에 인증서를 사용하도록 구성한다. (개인키는 서버에 안전하게 저장)


> #### SSL Handshake가 무엇인가요

클라이언트,서버가 보안연결을 할때 발생하는 프로세스
- 클라이언트에서 메시지(SSL/TLS버전 포함)를 서버에 전송해 handshake를 시작하고 서버가 메시지를 수신하면 서버는 메시지로 응답한다.

- 서버는 클라이언트와 서버 모두 호환되는 가장높은 SSL/TLS버전을 선택하고 공개키가 포함된 디지털 인증서를 보낸다

- 클라이언트는 인증서의 신뢰성, 무결성확인한다.

- 인증서 유효성 검사 성공시 클라이언트가 임의의 세션키를 생성해 인증서에서 얻은 서버의 공개키로 암호화해 서버로 보낸다. (서버에서만 해독될수있게)

- 서버에서 암호화된 세션키를 수신하여 서버의 개인키를 사용해 복호화한다.

- 클라이언트, 서버 모두 동일한 세션키를 가지게된다 


> #### SSL TLS 차이 

TLS가 SSL에서 업데이트된 안전한 버전이며, 두 용어는 종종 같은의미로 사용된다. 
더 나은 보안, 호환성을 위해 SSL버전이아닌 TLS를 사용하기도한다.

### Q) keep-alive 기능에 대해 설명해주세요

HTTP 통신을 하기위해 TCP연결을 먼저 하고 통신을 해야하는데 매번 요청이있을때마다 TCP연결을 하고 HTTP 통신을 하는게 아닌 TCP 연결을한번 해놓고 여러번의 HTTP통신을 할수있게끔 TCP연결을 유지하는 것입니다

### Q) GET,POST 메서드의 차이

GET: 리소스를 검색,조회할때 사용되는 메서드
POST: 리소스를 생성하거나 어떤요청을 처리할때 사용되는 메서드

> #### Q) 멱등성이란? GET은 멱등한가요?

멱등성은 요청을 여러번 보냈도 결과가 같은것을 의미합니다.
GET메서드는 특정한 리소스를 가져오도록 요청하는 메서드이며, 서버의상태를 변경시키지 않기때문에 멱등합니다

### Q) PUT과 PATCH의 차이

PUT은 리소스를 아예 붙여넣기(대체)하기때문에 멱등한 메소드이고
PATCH는 변화된 리소스부분만 수정하는 메소드로 멱등하지않다.


### Q) HTTP 1.1, HTTP 2 차이

- 다중화 : HTTP 1.1은 단일 TCP연결로 한번에 하나의 요청만 보낼수있는데 HTTP 2는 동시에 여러요청을 보내고 받을수있다.

- 헤더 압축 : HTTP2에서 헤더압축 사용해서 전송 데이터양을 줄여서 성능 향상

- 우선순위지정 : 각 요청의 우선순위를 지정할수있다.

> #### Q) HTTP 1.0, HTTP 1.1 차이

- Connection: Keep-alive 속성이 추가되었다.  1.0에서는 요청마다 새로운 TCP세션을 맺어야했는데 1.1에선 TCP 커넥션을 지속한다.

- HTTP 1.0에선 요청에대한 응답을 기다리고 다음 요청을 봅낼수있었는데 HTTP 1.1 에선 파이프라이닝기능을 통해 요청을 병렬로 처리할수있어 응답속도가 훨씬 빨라지게 되었다.

- 프록시 인증헤더가 추가되었다.

### Q) HTTP 3에대해 설명해주세요

- UDP기반의 프로토콜 QUIC를 사용하는 프로토콜
- UDP프로토콜을 선택하여 TCP프로토콜의 3way handshake 과정을 줄이고 한번의 왕복만으로 새 서버와 연결 + 암호화를 결합하는 방식을 사용한다

> #### Q) HTTP3에서 UDP를 사용하면서 TCP 의 신뢰성을 보장하는 방법에대해 설명해주세요

QUIC 의 고유한 신뢰성있는 메커니즘이 포함되어있다. 안정적인 패킷전달, 손실패킷 재전송, 혼잡제어를 제공한다. 
이는 TCP가 제공하는 손실제어 메커니즘을 따른다. 



### Q) 기존에 id가 1인 user의 이름(이영진), 성별(남자)이 존재하는상황에서 PUT /edit/1로 이름(김영진)으로 보내게된다면 어떻게 동작할까?

PUT 메소드는 데이터를 갈아치워서 덮어쓰기때문에 기존에있었던 이름(이영진), 성별(남자)의 데이터는 날아가고 **이름(김영진)**만 저장된다.

### Q) 등록을 할때 POST를 사용해야하는경우, PUT을 사용해야하는경우가 있는데 어떻게 구분할것인가?

uri에 식별자가 포함되냐 안되냐로 구분할수도있고, 멱등성의 유무로도 구분할수있다. 또한, 데이터를 덮어써도 되는상황인지 아닌지에 따라서도 구분할수있겠다.

> #### Q) POST 방식으로 응답코드를 201로 한다면 응답헤더에는 뭐가 실릴수있나요?


201 Created는 서버가 요청을 정상처리했고 새로운 리소스가 생겼다는 의미이다. 이때 Content-Location 으로 생성된 리소스의 위치를 명시할수있다.


### Q) HTTPS 의 장단점

장점 
- 통신을 암호화하기때문에 보안에 유리하다
- 인증서를 사용하기때문에 신뢰할수있는 통신을 할수있다.

단점 
- 암호화,복호화 알고리즘이 추가되어 HTTP에 비해 오버헤드가있을수있다.
- 인증서 설치,갱신 등의 관리가 필요하다

### Q) HTTP 캐싱에대해 설명해주세요

private cache : 한명의 사용자만 사용하는 캐시, 브라우저가 시도하는 모든 HTTP 요청은 브라우저 캐시로 라우팅되어 유효한 캐시가 있다면 캐싱한다. 

공유 프록시 cache : 한명 이상의 사용자에 의해 재사용되는 응답을 저장하는캐시, 특정지역 네트워크의 일부분으로 웹프록시를 설치해두고 캐싱할수있다.

### Q) 응답코드 401, 403의 차이를 설명해주세요

401응답코드는 인증되지않은 사용자가 인증이 필요한API에 요청한경우 사용합니다. 
403응답코드는 인증은 되었지만 권한이 부족한 사용자가(정회원이 필요한데, 준회원이 요청할때) 요청한경우 사용합니다.


### Q) 인증 vs 인가

인증: 사용자의 신원을 검증한다. ID, password 등을 확인하든 이메일로 인증하는 등 

인가: 사용자에게 특정 리소스나 기능에 액세스 할수있는 권한을 부여하는 프로세스


ref
- https://rachel-kwak.github.io/2021/03/08/HTTPS.html
