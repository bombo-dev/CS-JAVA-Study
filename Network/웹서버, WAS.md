# Web Sever, Web Application Server

- 웹 서버와 웹 애플리케이션 서버의 차이를 이해하기 전에 정적페이지와 동적페이지를 먼저 이해해야 한다.

**정적 페이지(Static Page)**
- 데이터베이스에서 정보를 가져오거나 별도의 서버에서의 처리가 없어도, 사용자에게 보여줄 수 있는 페이지
- 어떠한 사용자가 요청하던 간에 동일한 페이지를 보여준다.
- Ex) image, html, css, javascript 등등

**동적 페이지(Dynamic Page)**
- 서버에서 일련의 과정들을 거쳐서 데이터가 변할 수 있는 페이지.
- 주로 데이터를 요청하여 데이터베이스에서 데이터를 받아 보여주는 페이지들이다.
- 사용자가 누구인지에 따라 다른 페이지를 보여줄 수가 있다.

### 웹 서버(Web Server)와 웹 애플리케이션 서버(Web Application Server)의 차이

**웹 서버(Web Server)**
![Image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEl7zX%2FbtseSB6pu9J%2FieqUmLPXsm2KZ5jINbxefK%2Fimg.png)
1. **정적인 컨텐츠를 제공하고, WAS를 거치지 않고 자원을 바로 전달**한다.
2. 동적인 컨텐츠라면 **WAS에 전달하고, WAS가 처리한 결과를 받아서 클라이언트에게 응답 메시지를 전송**한다.
3. 아파치에서는 부가적인 기능으로 **CGI(Common Gateway Interface)** 를 제공하여 **웹 서버와 외부 프로그램 사이에서 정보를 주고 받을 수 있습니다.** 단, PHP, Perl, Python 에서만 가능하며 JAVA는 안됩니다.
- EX) Apache, Nginx, IIS   

**웹 애플리케이션 서버(Web Application Server, WAS)**
![Image](https://blog.kakaocdn.net/dn/dzROHQ/btrinP7Hryy/s0OadohZFwNMwbVqVXhGI1/img.png)
- 웹 서버로부터 오는 동적인 요청을 처리하는 서버, 웹 서버와 컨테이너를 붙여놓은 서버이다.

### Q) 웹 서버와 WAS가 어떤 차이로 각각 따로 존재해야하는지 설명해주세요.
- WAS는 웹 서버가 수행하는 기능을 같이 제공해 줄 수 있습니다. 그럼에도 불구하고 웹 서버가 필요한 이유는 WAS가 처리하는 일 중에서 비즈니스 로직을 수행하는 부분은 상당히 많은 비용을 소모하게 됩니다. (DB 트랜잭션, 스레드, 예외 등)
- 위의 비즈니스 로직을 수행하던 도중 큰 문제가 발생하여 WAS가 다운 될 경우, 웹 사이트에 오류가 발생했다는 정적 페이지도 뿌리지 못하고 접속 장애가 발생하는 상황이 발생합니다.
- 정적 페이지를 호출하는 부분은 웹 서버에게 일임하고, 동적인 부분을 처리하는 부분을 WAS에 일임하여 각 서버들끼리에 부하를 줄이고, WAS 문제 발생 시 웹 서버가 오류 페이지를 띄울 수 있도록 할 수 있습니다.
![Image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLpezI%2FbtseRiGiF6z%2FDNNqVsgGrbo3KIwKbbdvmK%2Fimg.png)
- 추가적으로, 웹 서버와 WAS를 분리하게 되면 웹 서버와 WAS간의 유연한 확장 또한 가능합니다. 웹 서버의 자원이 부족하면 웹 서버를 증설하고, WAS의 자원이 부족하면 WAS를 증설하는 것입니다.

### Q) 웹 서버와 WAS 분리 시 빌드 할 때의 장점에 대해서 설명해주세요.
- 정적 페이지는 주로 UI, UX 부분을 다루고 있기 때문에 잦은 수정이 일어나고 이에 따라 Build가 자주 발생 할 수 있습니다. 그러나 WAS 같은 경우 비즈니스 로직에 대해서는 수정이 정적인 페이지에 비해 잦은 편이 아닙니다.
- 이렇게 서로 간의 수정되는 정도가 다른데, 웹 서버가 제공하는 정적 페이지 제공하는 기능을 WAS에게 일임하면 변경 사항을 빌드하기 위해서 변하지 않은 비교적 무거운 비즈니스 로직적인 부분을 빌드를 같이 진행해야 하고 이 부분에서 빌드를 하는데 상당한 시간적 비용이 소모됩니다.
- 따라서, 분리를 했을 경우에는 이러한 시간적인 낭비를 줄일 수 있게 됩니다.

  ### Q) Java 프로그램으로 웹 개발을 하는 경우 직접 Socket 연결 및 요청 메시지, 응답 메시지 파싱을 하지 않아도 되는 이유에 대해서 설명해주세요.
  ![Image](https://doozi316.github.io/assets/images/WEB26/2.png)
  - WAS에는 웹 컨테이너라는 동적인 데이터를 처리해주는 공간이 있습니다. JAVA가 아닌 다른 Python과 같은 언어라면 CGI를 이용해 처리를 하게 해주는 것도 가능하지만, JAVA의 경우에는 제공이 안되므로 동일한 기능을 수행하는 서블릿이 Socket 연결, HTTP 요청 메시지 파싱, HTTP 응답 메시지 생성 등과 같은 일들을 편리하게 수행 할 수 있도록 해줍니다.
  
    ### Q) 웹 서버의 멀티 쓰레드 방식과 WAS의 멀티 쓰레드 방식
    - 해당 질문에 대해서는 자주 사용하는 웹 서버인 Apache와 NGINX의 관점에서 알 수 있습니다.   
    #### Apache   
    ![Image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVSwLI%2FbtseTDo7Y9m%2FhUYfINulKlOQOaOewUpDhK%2Fimg.png)
    - 리눅스의 관점에서 하나의 프로세스도 하나의 스레드로 여긴다고 봤을 때, 하나의 스레드가 하나의 요청을 처리하는 방식, 만약 프로세스 관점에서 본다면 멀티 프로세스 단일 스레드 형식으로 요청을 처리합니다.  
    #### NGINX
    ![Image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTwD47%2FbtseSCEd3Qt%2FThNWAYOKsmaK8ILnI0u11k%2Fimg.png)
    - NGINX는 위처럼 Event-Driven 구조를 택함으로써 하나의 프로세스에 멀티 쓰레드를 담는 구조를 택하고 있습니다. 이렇게 웹 서버를 이용하기 위한 연결을 택하게 되면 클라이언트가 웹 서버에 대한 요청에 대한 쓰레드를 받아서 처리하면서, WAS 또한 멀티 쓰레드 방식으로 동작하여, 요청이 들어오면 WAS 프로세스를 처리하기 위한 쓰레드를 추가하면서 동작을 하게 하거나, 쓰레드 풀을 이용해서 쓰레드 들을 담아놓고 웹 서버의 요청이 들어오면 WAS가 처리하도록 수행합니다.

    - 따라서 둘 간의 관점에서 봤을 때, 기본적으로 WAS는 대부분 멀티 쓰레드를 지원하며 웹 서버에 대한 멀티 쓰레드는 서버에 따라 다를 수 있음을 확인 할 수 있습니다.

### Q) 웹 서버와 WAS 종류를 한 가지 씩 설명해주세요.
- 웹 서버에는 NGINX가 있고, WAS에는 Tomcat이 있습니다.
  ### Q) 스프링 부트에서 제공해주는 WAS는 무엇일까요?
  - 스프링 부트는 자체적으로 Tomcat을 내장하고 있습니다.
    ### Q) 웹 서버는 OSI 7계층에서 어떤 계층에서 동작하는지에 대해서 설명해주세요.
      - 웹 서버는 웹 서버 자체도 프로그램이기 때문에 데이터 전송을 위한 Application 계층에 존재합니다.
      > Q) NGINX는 정적인 페이지에 대한 처리말고도 프록시 서버에 대한 역할도 수행하는데, 어떤 관점에서 수행되는지 설명해주세요.
      - **프록시 서버** : 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램, 프록시 서버는 크게 **Forward Proxy**와 **Reverse Proxy**로 나눌 수 있다.
      - **Forward Proxy** : 클라이언트가 인터넷에 직접 접근하는게 아니라 포워드 프록시 서버가 요청을 받고 인터넷에 연결하여 결과를 클라이언트에 전달해준다. 프록시 서버는 Cache를 사용하여 자주 사용하는 데이터라면 요청을 보내지 않고 캐시에서 가져올 수 있기 때문에 성능 향상이 가능하다.
      - **Reverse Proxy** : 클라이언트가 인터넷에 데이터를 요청하면 리버스 프록시가 이 요청을 받아 내부 서버에서 데이터를 받은 후 클라이언트에 전달한다. 내부 서버에 요청하지 않고 리버스 프록시에만 요청하면 프록시가 알아서 서버에게 데이터를 전달하기 때문에 안전하다. 추가적인 기능으로 로드 밸런싱 혹은 서버 확장등에도 유리하다.
      - **차이**
        1. **EndPoint 관점**
          - Forward Proxy는 클라이언트가 요청하는 End Point가 실제 서버 도메인
          - Reverse Proxy는 클라이언트가 요청하는 End Point가 프록시 서버의 도메인
        2. **감춰지는 대상 관점**
          - Forward Proxy 방식은 서버가 프록시 서버로 부터 요청을 받기 때문에 클라이언트의 정보를 알 수 없다.
          - Reverse Proxy 방식은 클라이언트가 프록시 서버에게 요청을 하기 때문에 서버의 정보를 알 수 없다.
      ### Q) 서블릿 컨테이너가 어떤 역할을 하는지 설명해주세요.
      - 서블릿 컨테이너는 자바에서 사용하기로 명시한 서블릿들을 보관해주어, 웹 서버와 손쉽게 통신 할 수 있도록 해주고, 소켓을 만들어 listen, aceept등의 API를 제공하여 HTTP 통신을 위한 복잡한 과정을 생략하게 해줍니다.
      - 서블릿의 생명 주기를 관리하며 멀티쓰레드 또한 지원을 합니다.
      
        ### Q) 서블릿의 요청에 따라서 응답을 달리 보내줄 수 있는데 어떻게 처리하는가
        - 서블릿에 대한 요청에서 Content-Type을 보고 해당 Content-Type에 맞게 데이터를 받게 될 때, 서블릿의 요청 헤더에 Accept가 어떤 것인지 혹은 API 규약이 어떤지에 따라 달라질 수 있습니다.
          1. Accept가 text/html 이라면 ModelAndView 를 반환하거나, 구 시대적인 방법으로 직접 html을 생성해서 보내주는 방법이 있습니다.
          2. Accept가 text/plain 이라면 response의 getWriter() 를 이용하여 반환이 가능합니다.
          3. Accept가 text/xml 혹은 application/json 이라면 ObjectMapper를 사용하여 객체로 변환하고, ResponseEntity를 사용하여 응답이 가능합니다.
          4. 이 외에도 요청에 따라 다양하게 응답이 가능합니다.
        - 질문의 의도는 HTTP 프로토콜에 따라 보내주는 요청에 따라 응답이 달라질 수 있다는 것.

### Q) 서버에 많은 트래픽이 발생했을 때 대처 할 수 있는 방안에 대해서 설명해주세요.
- 가장 간단한 방법은 클라우드 서버를 이용하고 있다면 서버를 증설하는 것이 가장 간단한 방법입니다.
- 만약 이러한 서버가 증설이 충분히 되어있음에도 불구하고 요청이 한 서버에만 몰려서 처리를 하게 되는 상황이라면 로드 밸런서를 설치하여 적절히 트래픽을 처리 할 수 있도록 하고 현재 요청을 받는 쓰레드가 부족하여 요청을 빠르게 수행 할 수 없는 상황이라면 적절하게 쓰레드 풀의 수를 늘려서 해결합니다.

  ### Q) 로드 밸런싱 기법에 대해서 설명해주세요.
  - 로드 밸런싱 기법에는 여러가지 방식이 있습니다. 서버의 능력을 고려하여 분배해야 하기 때문에 서버의 상황에 맞춰서 적절한 방법을 선택해주어야 합니다.
  1. **라운드로빈 방식(Round Robin Method)**
    - 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식입니다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결이 오래 지속되지 않는 경우에 적합합니다.
  2. **가중 라운드로빈 방식(Weighted Round Robin Method)**
    - 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분합니다. 주로 서버의 트래픽 처리 능력이 상이한 경우에 사용되는 부하 분산 방식입니다.
  3. **IP 해시 방식(IP Hash Method)**
    - 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식입니다. 사용자의 IP를 해싱해 로드를 분배하기 떄문에 사용자가 되도록 동일한 서버로 연결되는 것을 보장합니다.
  > 항상 동일한 서버로 연결되는 것을 보장한다고 써있었으나, DHCP를 이용 할 경우 보장 할 수 없으므로 되도록 이라는 말로 수정하였습니다. 
  4. **최소 연결 방식(Least Connection Method)**
    - 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분합니다. 세션이 길어지거나 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합합니다.
  5. **최소 응답 시간 방식(Least Response Time Method)**
    - 서버의 현재 연결 상태와 응답시간을 모두 고려하여 트래픽을 배분합니다. 가장 적은 연결 상태와 가장 짧은 응답 시간을 보이는 서버에 우선적으로 배분하는 방식입니다.

### 참고 자료
[Web Server VS WAS](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC)   
[NGINX](https://ssdragon.tistory.com/60)   
[Apache VS NGINX](https://velog.io/@deannn/Apache%EC%99%80-NginX-%EB%B9%84%EA%B5%90-%EC%B0%A8%EC%9D%B4%EC%A0%90)   
[Forward Proxy, Reverse Proxy](https://bcp0109.tistory.com/194)   
[로드 밸런싱](https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/)   
