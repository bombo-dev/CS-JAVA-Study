# JVM

자바 프로그램은 OS가 바로 해석할수있는 상태의 기계어가 아닌 바이트코드상태인데 이 바이트코드를 해석하고 실행할수있게 해주는 자바 가상머신입니다.

### JVM 메모리 구조에 대해 간단히 설명해주세요

- 클래스로더에서 .class파일을 읽어 .class파일의 데이터를 메소드영역에 저장하고 로드가 끝나면 해당 클래스타입의 class객체를 생성해 heap 영역에 저장한다.

- 메모리(런타임 데이터)영역은 JVM이 로드하고 실행할때마다 바이트코드, 객체, 변수등을 저장하기위한 메모리 공간들을 의미한다.

  - 스택: 스레드마다 스택이라는걸 만든다. 해당 스레드가 수행하는 메서드호출, 로컬변수 등의 정보를 포함하여저장한다. **스택에 저장된 데이터는 해당스레드에서만 사용가능해서 thread-safe하다**.
  
  - PC : 스레드마다 스레드내 현재 실행할 스택프레임을 가리키는 포인터가 생성된다.
  
  - 네이티브 메소드스택 : Native 메소드를 사용할떄 사용하는 별도의 스택
  
  - 힙: JVM시작시 생성되는영역 , 객체를 저장하는영역, **공유자원**이다.
  
  - 메소드: JVM시작시 생성되는영역,정적변수를 포함한 클래스 수준의정보(클래스이름, 부모클래스이름, 메소드,변수 등등)저장, 공유 자원이며, static zone/ non-static zone 으로 나뉜다.
  
> ### 바이트코드와 바이너리코드의 차이점에대해 설명해주세요

- 바이트 코드 : CPU가 아닌 가상머신에서 이해할수있는 코드를위한 이진표현법, 어떤 플랫폼에 종속되지않고 실행할수있는 기계어코드

- 바이너리 코드 : CPU가 이해할수있는언어로, 0과 1로 구성된 이진코드를 의미한다

- 바이트코드는 **가상머신에서 이해할수있는 코드를위한 표현법**이고, 바이너리코드는 **CPU가 이해할수있는언어로 구성된 이진코드**를 의미한다.

### JIT 컴파일러는 왜 생겼는가? 항상 사용하면 좋은건지?
- 바이트코드를 한줄씩 실행하는것이 인터프리터인데 반복되는 부분이 있는경우 JIT컴파일러가 바이트코드의 패턴을 내부적으로 감지해 native 코드로 변환하거나 컴파일후 캐싱하는등 인터프리터의 효율을 높이기위해 등장했다.

- 간단한 바이트코드라면 JIT컴파일러도 패턴을 감지하거나 내부적인 알고리즘이 있기때문에 비용이 있을것이고 인터프리터만 사용하는것이 좋을경우도 존재한다.  

### JVM 스택영역와 힙영역의 차이점

- 스택은 스레드별로 생기는공간으로 스레드간 공유가 되지않지만 heap은 스레드끼리 공유할수있는 공유자원이다.

- 스택은 해당 스택에서 호출한 메서드, 지역변수들의 정보를 저장하지만 heap은 객체를 저장한다.


### A a = new A(); 생성시
test라는 메서드에서 실행한다고 가정했을때
a라는 변수는 stack 영역에 저장되고 A객체가 heap에 생성되고 a변수가 heap에 있는 A객체를 가리키게된다.

### method 영역에는 어떤게 저장되나요?
클래스로더에서 .class파일을읽고 .class파일에 대한 메타정보를 저장하고 static변수들이 저장된다.

### String = "a", new String("a") 는 각각 어디에 생성되나요?
new String("a")로 생성하면 heap영역에 생길꺼고 , String = "a"로 생성하면 자바8이전이라면 method 영역에 있는 상수풀, 자바8이후이면 heap영역에 있는 상수풀에 저장됩니다.  
