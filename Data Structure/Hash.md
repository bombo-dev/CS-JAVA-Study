# 해시

### 1. 해시란?
  - 데이터의 효율적인 관리를 목적으로 임의의 크기를 가진 **데이터(Key)** 를 고정된 크기의 **데이터(Value)** 로 변화시켜 저장하는 것
  - Key와 Value를 이용해서 저장하므로, 데이터의 탐색 속도가 **O(1)** 에 수렴한다.

### 2. 해시 함수란?
  - 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑해주는 함수이다.
    1. **key** : 매핑 전 값
    2. **hash value** : 매핑후 값
    3. **hashing** : 매핑하는 과정
  
### 3. 해시 테이블이란?
  ![Image](https://i.imgur.com/NnEBDcX.png)
  - key를 hash value로 매핑하고 hash value를 인덱스 삼아서, 저장하고자 하는 value를 저장하는 자료구조이다.
  - **Bucket** 은 Hash Table에서 Data가 저장되는 공간이다.

  #### Q) 해시 충돌을 어떻게 해결하는지에 대해서 설명해주세요.
  - 해시 충돌은 Hash Value가 겹쳐서 같은 버킷에 저장하려고 할 때 발생합니다.
  - 해시 충돌의 해결 방법은 크게 2가지로 구분합니다.

  
  **Separate Chaining(분리 연결법)**   
  ![Image](https://i.imgur.com/7PTT8dT.png)
  
  - 해시 충돌 시 추가적인 메모리를 사용해 **LinkedList** or **Tree** 를 이용해서 해결하는 방법
  - cf) 자바 8 이상에서는 데이터의 사이즈가 커지면 Tree를 이용하고, RB 트리를 이용해 Balanced 트리로 만듦

  **Open Addressing(개방 주소법)**   
  ![Image](https://i.imgur.com/IM4FA2h.png)
  
  - chaining과 달리 한 버킷 당 들어갈 수 있는 value가 1개이다. 따라서, 해싱 이후 삽입 시에 이미 도출 된 hash value 버킷에 값이 있다면 다음 주소를 사용하는 방식으로 해결한다.
  - **Probing** : 해시 충돌 시 해시 테이블 내의 새로운 주소를 찾는 방법이다.
    1. **Linear Probing(선형 탐사)**   
      <img src="https://i.imgur.com/D1WrmZE.png" width=200>
      
      - 최초 해시값에 해당하는 버킷에 다른 데이터가 있다면 한칸씩 이동하여 해결한다.   
      **[문제]** : 특정 해시 값 주변 버킷이 모두 채워져 있는 primary clustering에 취약하다.

    2. **Quadratic Probing(제곱 탐사)**   
      <img src="https://i.imgur.com/KqvA9b9.png" width=200>
      
      - 고정 폭으로 이동하는 선형 탐사와 달리 폭이 제곱 수 만큼 늘어나 이동한다.   
      **[문제]** : 여러 개의 서로 다른 키들이 동일한 초기 해시값을 갖는 secondary clustering에 취약하다.
    
  - **Double Hashing(이중 해싱)**
      - 탐사할 해시 값의 규칙을 제거하는 방식이고 이를 이용해 클러스터링을 방지하기 위한 기법이고, 처음 버킷을 찾을 때의 해시 함수와, Probing을 위한 해시 함수를 별개로 사용한다.   
      **[문제]** : 3가지 중 캐시 효율이 가장 좋지 않고, 많은 연산량을 요구한다.
  - 개방 주소법을 사용한다는 것은 한 버킷 당 한 데이터 밖에 들어가지 못하기 떄문에, load factor가 1과 같거나 작아야 합니다.
    #### Q) 왜 Separate Chaining 방식에서 사이즈가 커지면 리스트가 아닌 트리 형식으로 자료를 저장하나요?
      - 트리는 **계층적 구조로 구성되어 있는 대용량 데이터를 저장하기 용이한 자료구조**이기 때문에 트리를 사용하는 것이고, Separate Chaining의 트리 방식은 보통 Balanced Tree로 구성되기 떄문에, **이진 탐색을 하는데 기존의 리스트의 탐색 시간인 O(N) 보다 낮은 O(logN) 만큼만 수행**하면 되기 때문에, 트리를 사용합니다.

  #### Q) 해시 테이블의 개념과 동작 원리에 대해서 설명해주세요.
  - key를 hash value로 매핑하고 hash value를 인덱스 삼아서, 저장하고자 하는 value를 저장하는 자료구조이다.
  - 해시 함수를 통해서 도출된 Hash Value를 이용하여 Hash Value를 인덱스로 가지는 버킷에 데이터를 저장함으로써 탐색할 떄 O(1) 로 수행할 수 있다는 장점이 있습니다. 
  - **Bucket** 은 Hash Table에서 Data가 저장되는 공간이다.

  #### Q) 해시 테이블의 장단점에 대해서 설명해주세요.
  - [장점] : 해시 테이블은 해시 충돌이 발생하지 않았다는 전제하에, 탐색을 O(1) 만에 수행 할 수 있습니다.
  - [단점] : 
    - 해시 충돌이 발생 할 경우 추가적인 연산이 필요하며, Separate Chaning 방식을 사용했을 경우 추가적인 탐색시간이 증가합니다. 
    - 해시 테이블에 대한 공간도 산정을 해주어야 하는데, 해시 테이블의 공간이 부족할 경우 resize를 해줘야 한다는 단점이 있습니다. 보통 load Factor가 0.75 이상이 되면 2배로 확장합니다.
    - 해시 테이블에 대한 정렬을 수행하려면 추가적인 자료구조를 사용해야합니다.
    
    #### Q) 자바에서의 HashTable과 HashMap의 차이
    - HashMap은 key와 value에 null을 허용하지만, HashTable은 null을 허용하지 않습니다. 
    - **HashMap** 은 데이터의 **동시성 처리를 보장**하지 않지만, **HashTable** 은 **데이터의 동시성 처리를 지원**해서 HashMap에 비해 상대적으로 연산 속도가 느립니다.
    - 최근에는 HashTable의 동시성을 개선한 **ConcurrentHashMap**을 사용합니다. 

  #### Q) 해시 테이블을 사용했을 때의 탐색, 삽입, 삭제에 대한 시간복잡도
  - 삽입, 삭제, 탐색 모두 해시 충돌이 밣생하지 않았을 경우에는 O(1)의 시간복잡도가 발생합니다.
  - 해시 충돌 발생 시 해시 충돌을 해결하는 방법에 따라 시간복잡도가 달라질 수 있으며, Separate Chaining 방식을 이용하여 리스트 자료구조를 이용하여 해결했을 경우에는 O(n)까지 중가할 수 있고, 트리 자료구조를 이용하여 해결했을 경우에는 O(logn) 까지 증가할 수 있습니다.

  #### Q) 해시를 사용하는 이유에 대해서 설명해주세요.
  - 자원을 관리하는 관점에서 보면 많은 양의 데이터를 적은 양의 데이터를 관리하기 위해서 사용하고, key-value 를 통해서 찾고자 하는 데이터를 빠르게 찾고자 할 때 용이합니다.

  #### Q) 해시 함수를 사용하는 이유와 없을 때의 문제점.
  - 해시 함수를 통해서 많은 양의 데이터를 적은 양의 데이터로 관리 할 수 있는데, 해시 함수를 사용하지 않는다면 들어오는 key 별로 데이터를 적재해야하기 때문에 메모리 낭비가 심해진다는 문제가 있습니다.

  #### Q) load-factor에 대해서 설명해주세요. 
  - 해시 테이블의 버킷에 평균 몇개에 데이터가 저장되는지에 대한 지표입니다.
  - N을 키의 개수, M을 해시 테이블의 크기라고 할 때, **N/M** 입니다. 
  - 따라서, N/M이 1을 초과하게 되면 해시 충돌이 발생합니다.

    #### Q) load-factor가 너무 작거나 크다면 어떤 문제가 있을까요?
    - load-factor가 너무 작다면 키의 개수에 비해 **해시 테이블의 크기가 너무 크게 책정되어 메모리가 낭비되고 있다는 것**을 의미합니다.
    - load-factor가 너무 크다면 **해시 충돌이 발생을 하게 되는 상황이고, 삽입, 삭제, 탐색 연산에 있어서 추가적인 연산이 발생**한다는 문제가 있습니다.
    - 따라서 위와 같은 문제를 해결하기 위해 적절하게 resize를 해줄 필요가 있습니다. 
