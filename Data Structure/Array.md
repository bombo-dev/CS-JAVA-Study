# 배열
배열이란, **동일한 자료형을 연속된 메모리 공간에 할당**하는 자료구조입니다.
연속된 공간에 저장되기 때문에, **0부터 시작하는 인덱스**를 통해 **값에 빠르게 접근**할 수 있다는 `O(1)` 장점이 있는 반면,
값을 **삽입/삭제** 하는 경우, 그 뒤의 **모든 요소들을 shift 하기 때문에 `O(N)` 비효율적**이라는 단점이 있습니다.

### Q) 배열과 리스트의 차이점에 대해 설명해주세요.
배열 : 초기 선언 시 **크기를 선언**하고, 크기 수정이 불가능합니다. (**고정적**)   
리스트 : 초기 선언 시 크기를 **선언할 필요가 없고**, 크기가 **가변적** 입니다.
  
  ### Q-1) ArrayList와 LinkedList의 차이점
  **ArrayList** : **데이터를 연속적으로 저장**하기 때문에 
  - 접근 `O(1)` : 인덱스를 통해
  - 삽입/삭제 `O(N)` : 뒤 shift
  
  **LinkedList** : **연속적인 공간에 저장하지 않고**, **각 노드가 데이터와 포인터**를 가지고 **포인터를 통해** 이전 노드와 다음 노드를 **연결**하기 때문에
  - 접근 `O(N)` : 순차적으로 탐색하며 접근
  - 삽입/삭제 `O(1)` : 앞뒤 링크만 변경

  ### Q-2) 배열과 리스트 둘 중 캐시의 지역성을 활용하기 좋은 건 뭘까요? (배열은 연속적으로 저장, 리스트는 불연속적으로 저장)
  - 배열입니다. 캐시의 지역성이란, 데이터 접근이 시간적 혹은 공간적으로 가깝게 일어나는 것을 의미합니다. **배열은 연속적으로 값을 저장하기 때문에, 특정 값에 접근하였을 때 주변 값에 빠르게 접근**할 수 있습니다. 이는 캐시의 지역성 중 공간적 지역성이 더 좋다고 표현할 수 있습니다.

  > 시간적 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성
  반복문 사용 시, 시간적 지역성이 좋다고 할 수 있습니다?


### Q) 배열같은 경우, index로 읽기에 속도가 빠르지만 검색 시 속도가 느립니다. 빠르게 검색할 수 있는 방법이 있을까요?
- 첫번째 답 : 배열의 경우 순차적으로 접근하기 때문에 매번 O(N)의 시간 복잡도가 소요됩니다. 
  하지만 **HashMap을 사용하여 값을 저장한다면 O(N)의 시간 복잡도로 저장**하고, 이후에는 매번 **O(1)의 시간으로 값**을 찾을 수 있습니다.

  **Q-1) 배열을 첫번째부터 다 돌면서 HashMap에 저장하면 괜찮을까요?** 
  - 비효율적
  
답 : **Binary Search** OR **선형 검색**

### 종운님 추가조사👍 : 이진 탐색은 현업에서 거의 사용하지 않고, Hash 를 사용한다고 합니다.   

1. Binary Search (이진 탐색 알고리즘) : 원하는 값을 찾고 싶을 때, 정렬된 리스트에서 검색 범위를 줄여 나가며 검색 값을 찾는 알고리즘입니다. - 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때 마다 검색 범위가 절반으로 줄어들기 때문에 속도가 빠르다는 장점이 있습니다.
  
   - 사용 방법
     - 처음에 N개 크기의 배열에서 단계가 하나씩 지나감에 따라 탐색할 배열의 크기를 반씩 줄입니다.   
  
   - 이진 탐색을 사용하는 경우 시간복잡도
     - 정렬되어 있지 않은 상태 : `O(NlogN)` (정렬) , `O(logN)` (값 탐색)
     - 정렬된 상태 : `O(logN)`    

2. 선형 탐색 : 일렬로 된 자료를 왼쪽부터 오른쪽으로 차례대로 탐색하는 것  
   - 매번 O(N)

**정리** 
- HashMap : O(N) 저장, 이후 O(1)
- Binary Search, 정렬X : O(NlogN) 정렬, 이후 O(logN)
- Binary Search, 정렬O : O(logN)
- 선형검색 : 매번 O(N)

### Q) 배열 내의 중복된 값이 존재하는 지 찾는 방법에 대해 설명해주세요.
요약: 배열은 `O(N^2)`의 시간복잡도가 소요되기 때문에, 중복요소를 저장하지 않는 **HashSet 자료구조를 사용**하여 `O(N)`의 시간복잡도로 값을 저장한 후 **HashSet과 배열의 크기를 비교**하면 됩니다.

---

배열은 값을 순차적으로 저장하기 때문에, 중복여부를 판단할 수 없습니다. 따라서 2중 반복문을 통해 판단하면 `O(N^2)`의 시간복잡도가 소요됩니다.
```java
for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    return true; // 중복 값 발견
                }
            }
        }
```
  
이를 효율적으로 검색하기 위해, 중복 요소를 허용하지 않는 HashSet 자료구조를 사용하면 됩니다. `O(N)`의 시간복잡도로 배열의 크기인 N만큼 HashSet에 추가한 뒤, HashSet의 크기와 배열의 크기를 비교하여 알아낼 수 있습니다. 
- `HashSet.size() == Array.size()` : 중복요소 없다
- `HashSet.size() != Array.size()` : 중복요소 있다
```java
public static boolean hasDuplicates(int[] arr) {
        HashSet<Integer> set = new HashSet<Integer>();
        for (int i = 0; i < arr.length; i++) {
            if (!set.add(arr[i])) {
                return true; // 중복 값 발견
            }
        }
        return false; // 중복 값 없음
    }
```

### Q) list와 set을 비교해주세요. 
💡 Hint! 중복과 순서 보장
- List : 중복 허용 O, 순서 보장 O
- Set : 중복 허용 X, 순서 보장 X

  ### Q-1) List와 Set을 사용하는 경우에 대해 설명해주세요.
  💡 Hint! A라는 친구가 집단안에 있는 지 확인하고 싶은 경우, 어떤 자료구조를 사용할까요? 
  - Set 입니다. contains 메소드를 통해 `O(1)`의 시간복잡도로 확인할 수 있습니다.
  - list 는 O(n)의 시간 복잡도가 걸리기 때문에, set을 사용하는 것이 효율적입니다.

  ✔️ List : 저장되는 데이터의 순서를 보장해야 할 때
    - 대기자 명단을 작성할 때   
   
  
  
  ✔️ Set : 데이터가 존재하는 지 확인하고 싶을 때 
    - 연락처 목록을 저장할 때

### Q) 배열의 softCopy와 deepCopy 에 대해 설명해주세요.
요약 : 자바의 객체와 같은 참조 변수는 직접 값을 저장하는 게 아닌 **힙 영역에 데이터를 저장하고 그의 주소값을 저장**하는 식으로 구성되어 있습니다. **softCopy**는 복사한 배열이 원래 배열의 **'주소값'을** 가져오고, **deepCopy는 '데이터'를** 가져옵니다.

---
<img width="806" alt="image" src="https://user-images.githubusercontent.com/67494004/230757706-7215961f-c4fb-40dc-8217-17b43571fc33.png">

설명을 위해 arr1 과 arr2 배열을 예시로 설명해보겠습니다.
arr1 의 값을 arr2에 복사하고 싶을 때, **`arr2 = arr1`는 softCopy** 입니다. (주소값만 복사, 같은 힙의 데이터를 바라봄)

  - arr2에 arr1의 `O(1)`의 시간복잡도로 모든 값이 복사됩니다. 하지만 이는 **배열의 주소값이 복사된 것으로, 메모리에서 동일한 배열을 참조**합니다. 따라서 **arr1 또는 arr2 의 값을 변경하게 되면, 동시에 변경**됩니다.
  
 반면 **`arr2 = arr[1].clone();` 이나 `System.arrayCopy(arr1, 0, arr2, 0, arr1.length)` 는 deepCopy** 입니다. (원본이 참조하고 있는 힙의 데이터까지 복제)

 - 이는 **배열 자체가 완벽하게 새 배열에 복사**됩니다. 전체 요소를 복사하기 때문에 `O(N)`의 시간복잡도가 소요됩니다.
  

> System.arraycopy()
- 배열의 일부분을 다른 배열로 복사할 때 사용

> clone() 주의 사항

1차원 배열, 단일 클래스 타입의 경우, clone()은 완벽히 다른 데이터를 참조합니다.
**하지만 클래스 타입을 여러개 담고 있는 배열**을 복사하는 경우, 
  - 참조 객체인 배열 자체는 완벽히 복사가 됩니다.
  - 하지만 **배열 내용물 객체**는 **얕은 복사**가 됩니다.
    - 원본과 복사본의 배열 요소가 담고있는 주소값이 같아 바라보는 힙 데이터가 같습니다.

이는 클래스를 복사할 경우, **clone()을 오버라이딩하여 재정의** 해줘야 합니다.

### Q) 배열을 정렬하는 경우, 어떤 알고리즘을 사용하는 경우 가장 효율적일까요?
- `O(NlogN)`의 시간복잡도를 가진 병합 정렬, 퀵 정렬을 사용합니다.
  
**자바 Arrays.sort()**
- primitive(기본형) 타입의 배열인 경우
  - 듀얼피봇 퀵정렬(Dual-Pivot QuickSort)를 사용
    - 듀얼피봇 퀵정렬은 일반적인 퀵정렬과는 다르게 피봇을 2개를 두고 3개의 구간을 만들어 퀵정렬을 진행한다고 합니다. 이 정렬방식은 랜덤 데이터에 대해서 평균적으로 퀵소트 보다 좋은 성능을 낸다고 알려져있습니다.

- reference(참조) 타입의 배열인 경우
  - 참조 타입의 배열인 경우는 TimSort를 사용

**자바 Collections.sort()**
-  TimSort 사용
   -  TimSort : 삽입(Insertion) 정렬과 합병(Merge) 정렬을 결합하여 만든 정렬

![image](https://user-images.githubusercontent.com/67494004/230757748-e2255865-ab32-4c70-9484-a84433d0d267.png)

>  Arrays를 정렬했을때와 Collections를 정렬했을때 왜 사용하는 알고리즘이 다른걸까요 ? 
(출처 : https://sabarada.tistory.com/138)   
그 이유는 바로 참조 지역성 원리(Local of Reference)에 있습니다. 참조 지역성의 원리란 동일한 값 또는 해당 값의 근처에 있는 스토리지 위치가 자주 액세스되는 특성을 말합니다. 이 참조 지역성의 원리는 CPU의 캐싱 전략에 영항을 미칩니다. 즉, CPU가 데이터를 엑세스하며 해당 데이터만이 아니라 인접한 메모리에 있는 데이터 또한 캐시 메모리에 함께 올려둡니다. 

정렬의 실제 동작 시간은 C * 시간복잡도 + a라고 합니다. 시간복잡도는 다 아시는 내용일 것이고 a 상대적으로 무시할 수 있습니다. 하지만 곱해지는 C의 영향도는 고려를 해야합니다. 생각하지 않을 수 없습니다. 이 C라는 값이 바로 참조 지역성 원리가 영향을 미칩니다.

Array는 메모리적으로 각 값들이 연속적인 주소를 가지고 있기 때문에 C의 값이 낮습니다. 그래서 참조 지역성이 좋은 퀵 정렬을 이용하면 충분한 성능을 제공할 수 있다고 합니다. 하지만 Collection은 List를 기준으로 봤을때 메모리간 인접한 ArrayList 뿐만 아니라 메모리적으로 산발적인 LinkedList도 함께 존재합니다. 따라서 참조 인접성이 좋지 않고 C의 값이 상대적으로 높다고 합니다. 이럴 때는 퀵 정렬 보다는 합병정렬과 삽입정렬을 병합한 Tim 정렬을 이용하는게 평균적으로 더 좋은 성능을 기대할 수 있다고합니다.



### Q) Map 에 대해 설명해주세요.
- Map은 Key(키)와 Value(값)으로 나눠 데이터를 관리합니다.
- HashMap 을 예시로 설명한다면, 해시테이블에 요소가 저장되어, 검색 시 `O(1)`의 시간 복잡도로 탐색할 수 있습니다.
- TreeMap 은 트리 구조로 저장되어, 요소 간 순서 보장이 필요할 때 `O(logN)` 의 시간복잡도로 탐색할 수 있습니다.

  ### Q-1) Key 중복이 되나요?
  - 중복이 허용되지 않습니다.

### Q) Hash가 저장되는 방식에 대해 설명해주세요.
- key값과 value값이 들어오면 **Key값이 Hash Function을 통해 고정된 길이의 hash로 변경**됩니다. 이 Hash가 저장위치가 되어, value값을 저장합니다.

- Hash Function
Input : Key, Output : Hash
key -- Hash Funtion(key) -- Hashing ... -> 고정된 길이의 hash

### Q) 배열은 선형 자료구조일까요, 비선형 자료구조일까요?
- **선형 자료구조** 입니다. 선형 자료구조는 **한 원소 뒤에 하나의 원소만이 존재하는 형태로 자료들이 선형으로 나열되어 있는 구조**입니다. 이는 **배열, 리스트, 큐, 스택 등**이 해당됩니다. 
- 반대로 **비선형 자료구조**는 **한 원소에 대해 다대다 관계**로 계층적 구조를 표현하는데 사용됩니다. 이는 **트리, 그래프** 등이 포함됩니다.
따라서 배열은 선형 자료구조 입니다.

### Q) Dynamic Array 에 대해 설명해주세요.
> 💡 자바에서 ArrayList는 List + Array 를 합친 개념입니다. 이 때 배열을 메모리에 연속적으로 저장하면서 크기도 동적으로 변할까? 를 생각
- 현재 배정된 memory를 증가시킬 때, 
    1. 확장된 메모리를 확보하고 (New Memory Allocation)
    2. 기존의 Array 값들을 새로운 매모리에 복사해줍니다. (Copy Array to New Memory)   
이를 자동으로 지원해주는 자료구조를 Dynamic Array 라고 합니다.

![image](https://user-images.githubusercontent.com/67494004/230757734-1c36e7e3-4ab5-4e84-9be7-b8e25131a74f.png)

- Size: 현재 값이 배정되어 있는 원소의 크기
- Capacity: 현재 배정된 메모리의 크기. 무조건 Capacity >= Size이어야 함.
- Scaling factor(Growth Factor): 새로운 원소가 들어와서 들어와서 Capacity가 모자라면, Capacity를 늘려야 합니다. 이 때 메모리를 기존 메모리 대비 몇 배나 확장하게 될 지 판단하게 되는데, 이 값을 Scaling Factor라고 합니다.
  - 당연하지만, 이 값이 엄청 크면, time 측면에서는 이득이 있으나, 메모리 공간에서는 손해를 봅니다.

만약 새로운 값들이 어레이에 계속 들어와서 Capacity와 Size 값이 같아진다면, 기존의 메모리를 유지한 채 새로운 메모리를 추가하는 것이 아니라, 현재 Size * GrowthFactor만큼의 메모리를 확보한 다음, 이 메모리에 기존 값을 모두 복사해줍니다.
 
- ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다.

### 참고
Copy : https://inpa.tistory.com/entry/JAVA-☕-Object-클래스-clone-메서드-얕은-복사-깊은-복사   
자바 정렬 비교 : https://codingnojam.tistory.com/38   
https://frhyme.github.io/datastructure/java_dynamic_array/



