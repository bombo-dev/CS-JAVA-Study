# 트리

### Q) 트리 중 이진트리에 대해 설명해주세요.

- 트리는 노드로 이루어진 자료구조로 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조입니다.
- 다음과 같은 특징이 있습니다.

  - 1. 트리는 하나의 루트 노드를 갖는다.

  - 2. 루트 노드는 0개 이상의 자식 노드를 갖는다.

  - 3. 자식 노드 또한 0개 이상의 자식 노드를 갖는다.

  - 4.  노드(Node)들과 노드들을 연결하는 간선(Edge)들로 구성되어 있다.

        - 트리에는 사이클(cycle)이 존재할 수 없다. 여기서 사이클이란 시작 노드에서 출발해 다른 노드를 거쳐 다시 시작 노드로 돌아올 수 있다면 사이클이 존재한다고 한다.
          <img width="500" alt="syn_async" src="https://user-images.githubusercontent.com/43171179/230992777-9fc2f839-5e00-4aaa-a6e1-83ce5edc752c.png">

        - 트리는 사이클(cycle)이 없는 하나의 연결 그래프(Connected Graph)라고 할 수 있다.
          트리의 노드는 self-loop가 존재 해서는 안된다.
          <img width="500" alt="syn_async" src="https://user-images.githubusercontent.com/43171179/230992820-29b1fe14-410f-439d-ba57-bbd9034af339.png">

          <img width="500" alt="syn_async" src="https://user-images.githubusercontent.com/43171179/230992835-55574a1f-40ef-4ff8-b0f1-d322c36569fa.png">

        **루트 노드(root node)** : 부모가 없는 노드로 트리는 단 하나의 루트 노드를 가진다. (ex : A- 루트노드)

        **단말 노드(leaf node)** : 자식이 없는 노드로 terminal 노드라고도 부른다. (ex : C, D, E - 단말 노드)

        **내부 노드(internal node)** : 단말 노드가 아닌 노드(ex : A, B - 내부 노드)

        **간선(edge)** : 노드를 연결하는 선

        **형제(sibling)** : 같은 부모 노드를 갖는 노드들 (ex : D-E, B-C : 형제)

        **노드의 깊이(depth)** : 루트 노드에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수(ex : D의 depth : 2)

        **노드의 레벨(level)** : 트리의 특정 깊이를 가지는 노드의 집합 ( ex : level 1- {B, C} )

        **노드의 차수(degree)** : 자식 노드의 개수 ( ex : B의 degree - 2, C의 degree - 0)

        **트리의 차수(degree of tree)** : 트리의 최대 차수 ( ex : 위 트리의 차수는 2이다)

### Q-1) 이진트리 검색과 삭제 시간 복잡도 평균에 대해 설명해주세요.

- 이진 트리의 검색과 삭제 시간 복잡도는 트리의 높이에 의해 결정됩니다. 따라서 이진 트리의 높이가 h라면, 검색과 삭제는 O(h) 시간이 걸립니다.

  이진 탐색 트리의 경우, 평균 높이는 O(log n)이므로 검색과 삭제의 평균 시간 복잡도는 `O(log n)`입니다. 이진 탐색 트리의 높이가 O(log n)이 되는 것은 키 값들이 무작위로 배치될 때 발생하며, 이 경우 대부분의 검색과 삭제 작업은 O(log n) 시간 안에 수행됩니다.

  하지만 이진 탐색 트리에서 키 값들이 일정한 패턴으로 배치되는 경우, 트리의 높이가 n-1이 될 수 있습니다. 이러한 경우, 검색 및 삭제 연산의 시간 복잡도는 O(n)이 됩니다.

  따라서, 이진 탐색 트리의 검색 및 삭제 연산의 평균 시간 복잡도는 O(log n)이며, `최악의 경우 O(n)`이 될 수 있습니다.

### Q-2) 편형된 트리를 보완할 수 있는게 있을까요?

- Balanced Tree(균형 트리)가 있습니다. 균형 트리는 트리의 높이가 가능한 작은 상태를 유지하는 이진 탐색 트리의 일종입니다. 이진 탐색 트리에서 키 값들이 무작위로 배치되지 않은 경우, 트리의 높이는 O(n)이 될 수 있습니다. 이 경우, 검색 및 삭제 작업의 시간 복잡도가 O(n)이 되므로 효율적인 이진 탐색 트리가 아닙니다.

반면에 균형 트리는 트리의 높이를 가능한 작게 유지하기 위해 노드의 삽입, 삭제 등의 작업을 수행할 때 트리의 구조를 조정합니다. 대표적인 균형 트리로는 AVL 트리, 레드-블랙 트리, B-트리 등이 있습니다.

### Q) AVL 트리와 레드블랙트리에 대해 알고계신가요?

- 이진탐색트리의 문제점을 극복할 수 있는 자료구조이다. 이진탐색트리에서 한쪽으로 노드가 쏠리게되면 최악의 경우 O(N)의 시간이 필요하기때문에 성능이 저하된다.

- AVL트리는 다음과 같은 특징을 가진다.

  - 이진 탐색 트리의 속성을 가진다.
  - 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다.
  - 높이 차이가 1보다 커지면 회전(Rotation)을 통해 균형을 맞춰 높이 차이를 줄인다.
  - 삽입, 검색, 삭제의 시간 복잡도가 O(log N)이다. (N : 노드의 개수)

- Balance Factor(BF)
  - 왼쪽과 오른쪽의 자식의 높이 차이를 뜻합니다.
- 회전
  - 불균형한 트리로 바로잡기 위해서는 회전이 필요합니다.

### Q-1) AVL과 레드블랙 차이에 대해 알려주세요.

1. AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 `Red-Black 트리보다 더 빠른 조회를 제공`

2. Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행

3. AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요

4. Red-Black 트리는 노드당 1비트의 정보만 필요합니다. (플래그 반전만 시키면 됨)

5. Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용, AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용

### Q) Balanced 트리의 시간 복잡도 최악이 어떻게 될까요?

- 균형 트리의 검색, 삽입, 삭제 연산의 최악 시간 복잡도는 `O(log n)`입니다. 이는 이진 탐색 트리의 경우와 동일하며, 트리가 균형을 유지하므로 트리의 크기 n에 대해 항상 일정한 시간 복잡도를 보장합니다.

### Q) 이진트리와 이진 탐색 트리를 각각 비교해서 설명해주세요.

- 이진 트리는 각 노드가 최대 2개의 자식 노드를 가지는 트리로, 왼쪽 자식 노드는 부모 노드보다 작은 값, 오른쪽 자식 노드는 부모 노드보다 큰 값이 저장됩니다.

- 이진 탐색 트리는 이진 트리의 일종으로, 각 노드의 왼쪽 자식 노드는 부모 노드보다 작은 값, 오른쪽 자식 노드는 부모 노드보다 큰 값이 저장되는 트리입니다. 이진 탐색 트리는 검색이나 정렬에 용이합니다.

### Q) 3가지 순회방식에 대해서 알고 계신가요?

- <img width="500" alt="syn_async" src="https://user-images.githubusercontent.com/43171179/231001189-30fe0e9c-2b11-4a0f-b2db-8be3978ee553.png">

  전위 순회 : 0->1->3->7->8->4->9->10->2->5->11->6

  중위 순회 : 7->3->8->1->9->4->10->0->11->5->2->6

  후위 순회 : 7->8->3->9->10->4->1->11->5->6->2->0

### Q) 정렬이 된 상태에서 출력한 값을 보고 싶다면 어떤 순회를 사용해야할까??

- 중위 순회는 왼쪽 서브트리, 현재 노드, 오른쪽 서브트리 순서로 노드를 탐색하는 방법입니다. 이진 탐색 트리의 특성 상 중위 순회를 사용하면 노드가 정렬된 순서대로 출력됩니다. 즉, 중위 순회를 수행하면 정렬된 값을 순서대로 출력할 수 있습니다.

  중위 순회의 시간 복잡도는 트리의 크기에 비례합니다. 따라서 이진 탐색 트리가 균형을 유지하는 경우, 중위 순회의 시간 복잡도는 O(n log n)입니다. 하지만, 트리의 높이가 매우 높은 경우, 중위 순회의 시간 복잡도는 O(n)이 될 수 있습니다.

### Q) 후위순회를 사용하는 사례에 대해 설명해주세요.

- 후위 순회는 이진 트리의 각 노드에 대한 작업을 수행하기에 적합합니다. 예를 들어, 후위 순회를 사용하여 이진 트리에서 수식을 계산하거나, 트리에서 각 노드의 깊이를 계산하는 등의 작업을 수행할 수 있습니다.

  또한, 후위 순회는 이진 트리에서 메모리 해제 등의 정리 작업을 수행할 때에도 유용합니다. 이는 노드의 자식 노드들을 모두 방문한 후, 부모 노드를 방문하며 메모리를 해제하기 때문입니다.

### Q) 해시테이블말고 이진 탐색 트리를 사용하는 이유와 각 차이에 대해 설명해주세요.

- 기능적인 측면에서 보면 탐색, 삭제, 삽입과 같은 기본기능들에 대해서, `해시 테이블` : O(1)
  `이진탐색트리` : O(logN) 정도 성능으로 동작한다.

      해시 테이블의 해시 함수의 비용과, 충돌 해결비용까지 고려하더라도 `데이터가 엄청 많아지는` 경우에는 해시 테이블이 효과적이라고 볼 수 있다. 그리고 만약 입력 사이즈를 알고 있다면, 입력 사이즈에 맞게 최적화된 해시 함수를 이용하여 해시 테이블의 해시 값을 균일하게 분포시켜서 성능을 최적화시킬 수 있을 것이다.



      하지만 이진탐색트리에는 `데이터들의 순서가 정렬`된 상태로 유지된다는 강력한 장점이 있다. 이 특성으로 인해 데이터를 정렬된 형태로 순회할 수 있다는 장점도 있겠지만, 아주 좋은 성능으로 범위기반 쿼리가 가능하다는 장점도 있다. 그러므로 `순서와 밀접한 연관이 있는 데이터` 를 다루는 상황에서는 이진탐색트리가 효과적일 것이다. 또한 문자열과 같은 데이터를 다루는 상황에서는 키의 동등 비교를 수행하는 해시 테이블보다, 키의 크기 비교를 수행하는 이진트리가 유리할 것이다.

- 메모리 측면에서보면 이진탐색트리는 딱 필요한 원소 만큼의 공간만을 할당하는 반면, 해시 테이블은 해시 적중률을 높이기 위해 `원소의 개수 이상의 메모리`를 유지해야한다. 그러므로 사용량 측면에서는 이진탐색트리가 유리하다.

- 캐시 적중률 측면에서 보면 이진탐색트리는 노드 기반 자료구조로 메모리 파편화가 진행되어 `캐시 적중률`이 떨어지게 된다. 반면, 해시 테이블은 배열 기반 자료구조로 연속된 메모리를 유지하기 때문에 `캐시 적중률이 상당히 높다`.

### Q) b-tree / b+tree 차이에 대해 설명해주세요.

- ![image](https://user-images.githubusercontent.com/43171179/231002733-cdbe6c03-a171-4080-a0e5-e5ae629a13b4.png)

  B-Tree 는 위 그림과 같이 생겼습니다. Binary-Tree 라고 오해를 하지만 Balanced-Tree 를 의미합니다. 자식이 2개 이상 가능합니다.

  B-tree 는 균형 트리로 루트로부터 리프까지의 거리가 일정한 트리 구조입니다. 이렇게 균형을 유지할 경우 어떤 데이터를 검색할 때 빠른 속도로 데이터를 찾을 수 있습니다. 하지만 만약 트리의 노드가 수정되어야 한다면 재정렬을 해줘야 하기 때문에 수정시 약점이 있습니다.

  MySQL의 InnoDB에서 사용되는 B+Tree 는 리프 노드를 제외하고 값을 담아두지 않기 때문에 하나의 블록에 더많은 Key 들을 담아 둘 수 있다 는 장점이 있습니다. 이는 곧, 트리의 높이가 낮아짐을 나타냅니다.

  풀 스캔시 B+Tree는 `리프 노드에 데이터`가 모두 있기 때문에 한번의 선형 탐색만 하면 되기 때문에 B-Tree 에 비해 빠르다 는 장점이 있습니다. 참고로 같은 레벨의 노드에서는 `Double Linked List` 를 사용하고 자식 노드는 `Single Linked List` 를 사용합니다.

### Q-1) 노드가 이진트리는 2개였는데 b-tree도 2개만 가지고 있나요?

- B-트리(B-tree)는 이진 트리와 달리 자식 노드의 개수가 정해져 있지 않습니다. 각 노드는 여러 개의 자식 노드를 가질 수 있습니다.

### Q) 완전 이진 트리랑 불안전 이진 트리는 어떻게 구분?

- 완전 이진 트리(Complete Binary Tree)는 모든 레벨에서 노드가 꽉 차 있고, 마지막 레벨에서는 오른쪽부터 순서대로 노드가 채워진 이진 트리를 말합니다. 이와 반대로, 불완전 이진 트리(Incomplete Binary Tree)는 모든 레벨에서 노드가 꽉 차 있지 않거나, 마지막 레벨에서 오른쪽에서부터 노드가 채워져 있지 않은 이진 트리를 말합니다.

### Q) 힙과 이진 탐색 트리의 차이점?

- 구현 방식

  `이진 탐색 트리`: 모든 노드의 왼쪽 서브트리에는 해당 노드보다 작은 값의 노드들이, 오른쪽 서브트리에는 해당 노드보다 큰 값의 노드들이 위치합니다. 각 노드의 값은 자신을 기준으로 왼쪽 서브트리에는 작은 값의 노드들만, 오른쪽 서브트리에는 큰 값의 노드들만 저장됩니다. 삽입/삭제 연산 시 최악의 경우 O(h)의 시간 복잡도를 가집니다. 이 때 h는 트리의 높이를 의미합니다. 만약 트리가 한쪽으로 치우쳐져 있을 경우, 삽입/삭제 연산 시간이 O(n)으로 급증할 수 있습니다.

  `힙`: `완전 이진 트리 형태`를 띄며, 부모 노드와 자식 노드 간의 대소 관계가 정해져 있습니다.
  노드 값의 저장 방식입니다. 부모 노드와 자식 노드 간의 대소 관계가 정해져 있어, 최대 힙(Max Heap)의 경우 부모 노드의 값이 자식 노드의 값보다 크고, 최소 힙(Min Heap)의 경우 부모 노드의 값이 자식 노드의 값보다 작습니다. 삽입/삭제 연산 시 `최악의 경우 O(log n)의 시간 복잡도`를 가집니다. 트리의 높이가 균형적으로 유지되기 때문에 이진 탐색 트리와 달리 삽입/삭제 연산 시간이 일정합니다.

  따라서 이진 탐색 트리는 `탐색 연산에 더 유리`하며, `삽입/삭제 연산이 빈번하지 않은 경우에 적합`합니다. 반면에 힙은 `최대/최소값을 빠르게 찾을 수 있으며`, `삽입/삭제 연산이 빈번한 경우에 적합`합니다.

### Q) 힙에도 작은 값은 왼쪽, 큰 값은 오른쪽으로 가는 성질이 적용될까요?

- 힙은 이진 탐색 트리와 달리 부모 노드와 자식 노드 간의 대소 관계가 정해져 있으며, 부모 노드의 값이 자식 노드의 값보다 큰 경우를 최대 힙(Max Heap)이라고 합니다. 최소 힙(Min Heap)의 경우는 부모 노드의 값이 자식 노드의 값보다 작은 경우입니다.

### Q) 이진 탐색트리랑 힙에서 중복된 값을 삽입하는게 가능할까요? (힙은 중복가능)

- 이진 탐색 트리는 중복을 허용하지 않고, 힙은 중복을 허용한다.

### Q) 힙 삽입 삭제 시 연산이 어떻게 일어날까요?

- 삭제할 값을 선택합니다. 최대 힙(Max Heap)의 경우 루트 노드에 있는 가장 큰 값을 선택하고, 최소 힙(Min Heap)의 경우 루트 노드에 있는 가장 작은 값을 선택합니다.

  삭제할 값을 힙의 맨 마지막 노드와 교환합니다.

  힙의 맨 마지막 노드를 삭제합니다.

  변경된 노드를 힙의 구조에 맞게 재정렬합니다. 최대 힙(Max Heap)의 경우, 루트 노드로부터 아래로 내려가며 자식 노드 중 가장 큰 값을 가진 노드와 교환해 나가며 정렬합니다. 최소 힙(Min Heap)의 경우도 마찬가지로, 루트 노드로부터 아래로 내려가며 자식 노드 중 가장 작은 값을 가진 노드와 교환해 나가며 정렬합니다.
