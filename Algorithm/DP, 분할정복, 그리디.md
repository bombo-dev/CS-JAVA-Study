# DP
- DP란 **복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법**을 말합니다. DP에서는 2가지 조건을 충족해야 만 사용이 가능합니다.
  1. **부분 반복 문제**(Overlapping Subproblem) 
    - 어떤 문제가 여러 개의 부분 문제로 쪼개질 수 있는 경우를 말합니다.
  2. **최적 부분 구조**(Optimal Substructure)
    - 작은 부분 문제에서 구한 최적의 답으로 큰 문제를 해결할 수 있는 경우를 말합니다.
  
  이때, 분할 정복과의 가장 큰 차이는 **분할 정복법은 작은 문제의 답이 달라질 수 있지만, DP는 그렇지 않다는 것**입니다.

- DP를 구현 할 때에는 **Memoization**과 **Tabulation**을 사용해서 구현이 가능합니다.
  1. **Memoization** 
    ![Image](https://nulls.co.kr/media/post-body/2021/11/11/image_RO5Twnq.png)
    - 재귀를 이용해서 문제를 해결 할 경우에 사용하는 테이블, **Top-Bottom** 으로 해결 할 경우 사용
  2. **Tabulation**
    ![Image](https://nulls.co.kr/media/post-body/2021/11/11/image_NfyGvHQ.png)
    - 반복문을 이용해서 문제를 해결 할 경우에 사용하는 테이블, **Bottom-Up**으로 해결 할 경우 사용

  #### Q) DP의 2가지 조건에 대해서 설명해주세요.
    - 어떤 문제가 여러 개의 부분 문제로 쪼개질 수 있는 경우인 **부분 반복 문제**를 충족해야 하고, 작은 부분 문제에서 구한 최적의 답으로 큰 문제를 해결할 수 있다는 **최적 부분 구조** 를 충족해야 합니다. 

  #### Q) Top-Bottom 방식과 Bottom-Up 방식의 장단점에 대해서 설명해주세요.
    - **Top-Bottom**
      **[장점]** : 재귀를 이용한 방식이기 때문에 **가독성이 좋고, 서브 문제를 해결 할 경우 필요한 서브 문제들만 해결해도 된다는 장점**이 있습니다.   
      **[단점]** : 결과가 어떻게 나오는지 알고 있어야 하며, **저수준으로 갈 수록 복잡해질 수 있으며, 리소스의 사용이 많아질수 있다**는 문제가 있습니다.

    - **Bottom-UP**
      **[장점]** : **처리 시간과 리소스 사용을 줄일 수 있고, 점화식을 찾은 경우에 점화식을 이용하여 문제를 해결 할 수 있다는 장점**이 있습니다.
      **[단점]** : 반복문으로 진행하다보니 **재귀 방식에 비해서 구현이 복잡** 할 수 있으며, Top-Bottom은 대 문제를 해결하기 위해 필요한 소 문제에 대해서만 구현을 하면 되지만 Bottom-Up 방식은 **처음부터 해결해야 하는 대문제까지의 모든 경우를 구해야 한다**는 단점이 있습니다.

### 참고
[이미지 출처](https://nulls.co.kr/codeit/392)

---
# 분할정복
-

---

# Greedy
- 그리디란 **미래를 생각하지 않고 현재 단계에서 가장 최선의 선택을 하는 기법**입니다 . 순간마다 하는 선택은 그 순간에 대해 지역적으로 최적이지만, 모았을 때 그것이 **최적의 해라는 보장은 없습니다.**      
- 그리디로 해결이 안되는 상황을 예시로 설명해보겠습니다. 지금 선택하면 1개의 쿠키를 받고, 1분 기다렸다 선택하면 2개의 쿠키를 받는 문제 가 있을 때 지금 **당장 최선의 선택은 쿠키 1개**를 받는 거지만, **결과적으로는** 1분 기다렸다가 **2개 받는 선택이 최선**입니다.

### Q) 그리디와 DP의 차이점에 대해 말씀해주세요.
문제를 작은 문제로 분할하여 해결하거나, 부분 문제의 최적해를 활용해 전체 문제의 최적해를 구한다는 문제 해결 방식은 동일합니다.
하지만 그리디는 **각 단계에서 최선의 선택을 하기 때문에 현재 선택이 나중에 영향을 끼친다**면 이는 최적의 해를 보장할 수 없습니다. 따라 이런 경우에는 **DP**, 영향을 끼치지** 않을 때 그리디**를 사용합니다.

### Q) 속도 측면에서는 뭐가 더 우세할까요?
**그리디 알고리즘**입니다.
**동적 프로그래밍 알고리즘**은 중복 계산을 피하고 전역적인 최적해를 보장하기는 하지만, **메모리 공간을 많이 사용**하고, 부분 문제들의 결과를 계산하고 저장하는 과정이 복잡하기 때문에 일반적으로 **그리디 알고리즘보다 더 높은 시간복잡도**를 가질 수 있습니다.

---


<img width="810" alt="Untitled-3" src="https://user-images.githubusercontent.com/67494004/231194550-af3fb37b-8e06-499f-818c-61efd7ba7828.png">

### 참고
[이미지 출처](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm)
