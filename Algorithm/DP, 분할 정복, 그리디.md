# DP
- DP란 **복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법**을 말합니다. DP에서는 2가지 조건을 충족해야 만 사용이 가능합니다.
  1. **부분 반복 문제**(Overlapping Subproblem) 
    - 어떤 문제가 여러 개의 부분 문제로 쪼개질 수 있는 경우를 말합니다.
  2. **최적 부분 구조**(Optimal Substructure)
    - 작은 부분 문제에서 구한 최적의 답으로 큰 문제를 해결할 수 있는 경우를 말합니다.
  
  이때, 분할 정복과의 가장 큰 차이는 **분할 정복법은 작은 문제의 답이 달라질 수 있지만, DP는 그렇지 않다는 것**입니다.

- DP를 구현 할 때에는 **Memoization**과 **Tabulation**을 사용해서 구현이 가능합니다.
  1. **Memoization** 
    - <img src="https://nulls.co.kr/media/post-body/2021/11/11/image_RO5Twnq.png" width="300">
    
    - 재귀를 이용해서 문제를 해결 할 경우에 사용하는 테이블, **Top-Bottom** 으로 해결 할 경우 사용
  2. **Tabulation**

    ![Image](https://nulls.co.kr/media/post-body/2021/11/11/image_NfyGvHQ.png)
    - 반복문을 이용해서 문제를 해결 할 경우에 사용하는 테이블, **Bottom-Up**으로 해결 할 경우 사용

  #### Q) DP의 2가지 조건에 대해서 설명해주세요.
    - 어떤 문제가 여러 개의 부분 문제로 쪼개질 수 있는 경우인 **부분 반복 문제**를 충족해야 하고, 작은 부분 문제에서 구한 최적의 답으로 큰 문제를 해결할 수 있다는 **최적 부분 구조** 를 충족해야 합니다. 

  #### Q) Top-Bottom 방식과 Bottom-Up 방식의 장단점에 대해서 설명해주세요.
    - **Top-Bottom**   
      **[장점]** : 재귀를 이용한 방식이기 때문에 **가독성이 좋고, 서브 문제를 해결 할 경우 필요한 서브 문제들만 해결해도 된다는 장점**이 있습니다.   
      **[단점]** : 결과가 어떻게 나오는지 알고 있어야 하며, **저수준으로 갈 수록 복잡해질 수 있으며, 리소스의 사용이 많아질수 있다**는 문제가 있습니다.

    - **Bottom-UP**   
      **[장점]** : **처리 시간과 리소스 사용을 줄일 수 있고, 점화식을 찾은 경우에 점화식을 이용하여 문제를 해결 할 수 있다는 장점**이 있습니다.
      **[단점]** : 반복문으로 진행하다보니 **재귀 방식에 비해서 구현이 복잡** 할 수 있으며, Top-Bottom은 대 문제를 해결하기 위해 필요한 소 문제에 대해서만 구현을 하면 되지만 Bottom-Up 방식은 **처음부터 해결해야 하는 대문제까지의 모든 경우를 구해야 한다**는 단점이 있습니다.

---
# Divide & Conquer (분할 정복)
* 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘입니다. 
- **하향식 접근법** 으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 (top-down) 하위의 해답을 구하는 방식으로 수행됩니다.
- 일반적으로 재귀함수로 구현합니다. 
> **divide-and-conquer의 핵심은 재귀호출입니다.**
- Divide & Conquer은 `top-down` 접근 방식을 사용합니다. 
- 이때 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않습니다. top-down이란, 처음부터 큰 문제를 방문 후 작은 문제를 호출, 재귀(recursive)방식을 사용합니다.
(ex) 병합 정렬, 퀵 정렬 등

#### 분할 정복 용어
- Divide : 문제를 더 작은 문제로 분할하는 과정
- Merge : 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정(merge)
- Base case : 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

### Q) 분할정복의 장단점을 설명해주세요
- 장점 : 큰 문제를 재귀적으로 나누어 해결하기에 간단하지만 빠르며 병렬적으로 문제를 해결할 수 있다는 장점이 있습니다. 
- 단점 : 재귀적으로 문제를 해결하기 때문에 인풋이 너무 큰 경우 많은 프로그래밍 언어에서 Stack Overflow가 발생할 수 있으며, 이는 메모리의 비효율적 사용을 야기할 수 있습니다.

### Q) DP와 분할 정복의 공통점과 차이점을 설명해주세요

**DP와 분할 정복의 공통점**
- 문제를 잘게 쪼개서, 가장 작은 단위로 분할한다는 것입니다. 

**DP와 분할 정복의 차이점**

1) **동적 계획법**
- DP의 부분 문제는 중복되기에 상위 문제 해결 시 재활용됩니다. 따라서 DP는 서로 상관관계가 있는 문제를 해결하는데에 적합합니다.
- Memoization 기법을 사용합니다.(부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)

2) **분할 정복**
- 분할정복의 부분 문제는 서로 중복되지 않습니다. 따라서 분할정복은 서로 상관관계가 없는, 쪼개진 결과가 서로 독립적인 성격의 문제를 해결하는데 적합합니다. 
- Memoization 기법을 사용하지 않습니다. 

---

# Greedy
- 그리디란 **미래를 생각하지 않고 현재 단계에서 가장 최선의 선택을 하는 기법**입니다 . 순간마다 하는 선택은 그 순간에 대해 지역적으로 최적이지만, 모았을 때 그것이 **최적의 해라는 보장은 없습니다.**      
- 그리디로 해결이 안되는 상황을 예시로 설명해보겠습니다. 지금 선택하면 1개의 쿠키를 받고, 1분 기다렸다 선택하면 2개의 쿠키를 받는 문제 가 있을 때 지금 **당장 최선의 선택은 쿠키 1개**를 받는 거지만, **결과적으로는** 1분 기다렸다가 **2개 받는 선택이 최선**입니다.

### Q) 그리디와 DP의 차이점에 대해 말씀해주세요.
문제를 작은 문제로 분할하여 해결하거나, 부분 문제의 최적해를 활용해 전체 문제의 최적해를 구한다는 문제 해결 방식은 동일합니다.
하지만 그리디는 **각 단계에서 최선의 선택을 하기 때문에 현재 선택이 나중에 영향을 끼친다**면 이는 최적의 해를 보장할 수 없습니다. 따라 이런 경우에는 **DP**, 영향을 끼치지** 않을 때 그리디**를 사용합니다.

### Q) 속도 측면에서는 뭐가 더 우세할까요?
**그리디 알고리즘**입니다.
**동적 프로그래밍 알고리즘**은 중복 계산을 피하고 전역적인 최적해를 보장하기는 하지만, **메모리 공간을 많이 사용**하고, 부분 문제들의 결과를 계산하고 저장하는 과정이 복잡하기 때문에 일반적으로 **그리디 알고리즘보다 더 높은 시간복잡도**를 가질 수 있습니다.

---


<img width="810" alt="Untitled-3" src="https://user-images.githubusercontent.com/67494004/231194550-af3fb37b-8e06-499f-818c-61efd7ba7828.png">

### 참고
DP   
[이미지 출처](https://nulls.co.kr/codeit/392)

   
분할정복   
[이미지&내용 출처](https://syujisu.tistory.com/entry/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-Dynamic-Programming%EA%B3%BC-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-Divide-and-Conquer-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

[이미지&내용 출처](https://korguy.tistory.com/entry/%EB%B0%A9%EB%B2%95%EB%A1%A0-Divide-and-Conquer-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5)
   
그리디   
[이미지 출처](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm)
